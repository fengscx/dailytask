# 总

## 1. Java基础+集合+多线程+JVM

### 1. Java基础

- 面向对象与面向过程的区别

  面向过程：以过程为中心，分析问题用函数实现，性能高，扩展性差

  面向对象：以对象为核心，对现实世界的理解和抽象，封装继承多态，扩展性好。

- Java性能差的主要原因

  Java是半编译的语言，编译生成.class字节码，然后由JVM转化为二进制机器码

- Java语言特点

- JVM

  Java虚拟机是运行Java字节码的虚拟机。针对不同系统有特定的实现，目的是使用相同的字节码，得到相同的结果

- 字节码，字节码的好处

  JVM可以理解的代码就是字节码（.class），不面向特定的处理器，只面向虚拟机。一定程度上提高了语言执行效率，又保留了可移植的特性

- java编译流程

  .java 源文件经过JDK中的javac编译得到.class字节码然后通过JVM翻译为二进制机器码

  **JIT（Just in time, 即时）编译器**

  运行时编译，完成一次编译后，将字节码对应的机器码保存下来下次直接使用。

  **AOT（Ahead of Time，运行前）编译器**

  运行前编译，直接将字节码编译成机器码，运行的初期就能达到最高性能

- HotSpot的编译

  HotSpot采用惰性评估，消耗大部分资源的是一小部分代码，JIT需要编译的部分。JVM根据执行情况优化，执行次数越多，速度越快。

- JDK与JRE

  JDK 是Java Development Kit 是Java开发套件，有JRE的一切，还有编译器(javac)和工具(javac和jdb调试器)。能创建和编译程序

  JRE是Java运行时环境，运行已编译Java程序所需的所有内容的集合，包括Java虚拟机，Java类库等一些基础构件，不能用于创建新程序。

  JSP需要JDK环境

- Oracle JDK与Open JDK

  非常接近，Oracle JDK版本构建过程基于Open JDK 7，只添加了几个部分

  OpenJDK 比 Oracle JDK更新快

  OpenJDK是参考模型且免费，OracleJDK是它的一个实现

  OracleJDK比OpenJDK稳定，性能更好 

- Java和C++的区别

  - Java不提供指针直接访问内存，程序内存更安全
  - Java的类是单继承的，C++支持多继承
  - Java有自动内存管理，C++没有

- 字符型常量和字符串常量的区别

  - 单引号，双引号
  - 含以上，字符型常量相当于一个整型值（ASCII）,字符串常量表示一个地址
  - 占内存大小上，字符型常量占2字节，字符串常量占若干

- 8中基本类型以及所占大小

  boolean, char 2字节，byte 1字节，short 2字节，int 4字节，long 8字节

  float 4字节，double 8字节

- 构造器是否可以被重写

  构造器不能被重写(override)，但可以overload。

- 重载（Overload）与重写（Override）的区别

  **重载**：发生在同一个类中，方法名必须相同，参数类型，个数，顺序不同。

  不能用返回值类型来区分

  **重写**：子类对父类允许访问的方法的实现过程进行重新编写

  [方法名，参数列表必须同，返回类型，抛出异常范围小于等于父类，访问修饰符范围大于等于父类]

- 封装，继承与多态

  - 封装：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。隐藏内部细节通过接口与外部联系。

  - 继承：子类继承父类，获得代码的重用。

    遵循里式替换原则，子类必须能替换所有父类起相同的作用

  - 多态

    **运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才能确定**

    运行时多态：1.继承，2.覆盖（重写）3. 向上转型

    ~~编译时多态：重载~~

- String,StringBuffer,StringBuilder的区别

  String类使用final 关键字修饰**字符数组**来保存字符串，JDK 9以后改用byte数组。

  StringBuilder 与 StringBuffer 都继承自AstractStringBuilder类，使用字符数组保存字符串char[] ，但没有final关键字修饰

  Stringbuffer对方法加了同步锁，线程安全，Stringbuilder没有

  每次改String都会生成新的String,然后将指针指向新的

  - 操作少量数据：String
  - 单行程字符在缓冲区操作大量数据StringBilder
  - 多线程操作缓冲区大量数据：StringBuffer

- 自动装箱与拆箱

  - 装箱：将基本类型用他们对应的引用类型包装起来
  - 拆箱：将包装类型转换为基本类型

- 在一个静态方法内调用一个非静态成员为什么是非法的？

  静态方法可以直接通过类名来访问，因此静态方法里不能调用其他非静态变量也不能访问非静态变量成员

- Java中定义一个不做事且没有参数的构造方法的作用

  在执行子类的构造方法之前，若没有用super()调用父类特定的构造方法，则会调用父类中无参构造方法，若父类中只有有参构造方法，编译时错误

- 接口和抽象类的区别是什么

  接口默认public，JDK1.8之前所有方法在接口中不能有实现，而抽象类中可以有非抽象方法

  一个类可以实现多个接口，但只能继承一个抽象类

  接口默认修饰符public,抽象方法可有public,protected和default

  设计上，一个是对行为的抽象，一个是对类的抽象

  - public：可以被所有其他类访问
  - private：只能被自己访问和修改
  - protected：自身，子类和以及同一个包中的类可以访问
  - default：同一个包中的可以访问

- 成员变量与局部变量的区别

  成员变量属于类，局部变量是在方法中定义的变量或方法的参数

  成员变量可被访问控制符修饰

  没有用static修饰，成员变量属于实例，用了属于类，放于堆中

  局部变量为基本数据类型，引用则存放地址，存在栈中。

- 创建一个对象用什么运算符？对象实例与对象引用有何不同？

  new,new创建的对象实例在堆内存中，对象引用指向对象实例

  引用可指向0或1个对象，对象可被n个引用指向

- 什么是方法返回值？返回值在类的方法里的作用是什么？

  方法执行后产生的结果，返回值用于接收结果

- 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？

  完成对象的初始化，可以，类中有默认的无参构造

- 构造方法有哪些特性？

  名字与类名相同，没有返回值，生成对象时自动执行

- 静态方法和实例方法有何不同？

  外部调用静态方法时可以用“类名.方法名”，也能用对象名.方法名方式。实例方法只有后面那种

  静态方法只能访问静态成员，实列无限制

- 对象相等与指向他们的引用相等，两者有什么不同？

  对象相等指存在内存中的内容相等。引用相等是指向的内存地址相等

- 在调用子类构造方法之前会先调用父类没有参数的构造方法，目的是？

  帮助子类做初始化工作

- **== 与 equals**

  ==：判断两个对象的地址是否相等

  equals(): 没有重写时也是比较内存地址，重写后比较内容是否相等

- **hashCode()**

  获取哈希码，实际上返回一个int整数。作用就是确定该对象在哈希表中的索引位置，hashCode()定义在JDK的Object类中

- 为什么要有hashCode

  hashSet等集合需要使用，HashSet会计算对象的hashCode值来判断对象加入的位置，同时与其他已经加入的对象的hashCode值比较。hashcode相同才调用equals()比较

- 为什么重写equals时必须重写hashCode方法？https://blog.csdn.net/qq_35868412/article/details/89380409

  **使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率**

  **如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况**

- 两个对象有相同的hashCode，也不一定相等？

  hash算法可能让不同的对象产生同样的hashCode，这就是碰撞

- 为什么说Java只有值传递？

  Java 的参数是以值传递的形式传入方法中，而不是引用传递。

  引用存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。

- 简述线程，程序，进程的基本概念。以及他们之间的关系

  线程是独立调度的基本单位，一个进程中可以有多个线程，它们共享进程资源，线程切换时开销比较小，也被称为轻量级进程

  进程是程序的一次执行，资源分配的基本单位，是动态的。PCB描述进程的基本信息和运行状态，创建或撤销线程都是对PCB的操作

  程序是数据和指令的集合，是静态的。

- 线程的基本状态

  NEW初始状态（线程被构建但没有调用Start()），

  RUNABLE运行状态（操作系统的就绪和运行两种状态）,

  BLOCKED阻塞状态，线程调用同步方法时没得到锁就会进入到BLOCKED

  WAITING等待状态（当前线程需要等到其他线程做出特定动作），-执

  行wait()

  TIME_WAITING超时等待状态（可以在指定时间内自行返回），-执行

  wait(millis) 或 sleep(millis)

  TERMINATED（终止状态，线程已执行完）. 执行run()方法后

- final关键字

  final变量（不能修改变量值），final类（不能被继承），final方法（不能被重写）

- Java中的异常处理
  
  所有异常的共同祖先java.lang包中的Throwable类，Throwable的Error,Exception两大子类
  
  - Error ：JVM无法处理的错误，例如Java虚拟机运行错误，OOM，类定义错误
  
  - Exception：
  
    受检异常-需要用try...catch...捕获并处理，且可以从异常中恢复
  
    受检异常不被处理无法通过编译（IOExeption）,ClassNotFound
  
    非受检异常-程序运行错误，例如除0，程序崩溃且无法恢复
  
    NullPointException,数组越界，算术错误
  
  - Throwable
  
    getMessage() ：返回异常发生时的简要描述
  
    toString()：异常发生时的详细信息
  
    printStackTrace(): 控制台打印异常信息
  
  - 异常处理总结
  
    try块：用于捕获异常，其后接0个或多个catch块
  
    catch块：处理try捕获到的异常
  
    finally块：无论是否捕获异常，finally块的语句都会被执行
  
    **当try或catch中遇到return语句时，finally语句将在返回之前被执行**
  
    **当try和finally中都有return 时，finally中的语句将会覆盖原始返回值**
  
    **finally块不会被执行：**
  
    1.try或finally中用了System.exit(int)
  
    2.程序所在的线程死亡
  
    3.关闭CPU
  
- Java序列化中有些字段不想序列化怎么办？

  transient关键字：阻止实例中被修饰的变量序列化，反序列化时，被transient修饰的变量不会被持久化和恢复

- 获取键盘输入的的两种方法

  ```java
  Scanner input = new Scanner(System.in);
  s = input.nextLine();
  ```

  ```java
  BufferReader input = new BufferReader(new InputStreamReader(System.in));
  s = input.readLine();
  ```

- Java 中的I/O
  - IO流分类
  
    按照流向分类，可分为输入流和输出流
  
    按照操作单元分类，可分为字节流和字符流
  
    按照流的角色分类可分为节点流和处理流
  
    - InputStream/Reader：所有输入流的基类，前者是字节输入流，后者是字符输入流
    - OutputStream/Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流
  
  - 字节流与字符流
  
    ~~编码就是把字符转换为字节，而解码是把字节重新组合成字符~~
  
    本质上所有的读写操作都是以字节为单位进行的，Java语言提供了基于字符的流是为了给处理字符提供更更方便、更有效的方法
  
    用字节流处理二进制数据，例如图片
  
    用字符流处理字符和字符串
  
  - BIO,NIO,AIO
  
    - BIO(Blocking I/O)：同步阻塞I/O模式
  
      数据读取写入必须阻塞在一个线程内等待其完成，让每个连接专注于自己的I/O且编程模型简单。
  
    - NIO(Non-blocking/New I/O)：同步非阻塞的I/O模型
  
      支持面向缓冲的，基于通道的I/O操作方法。NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件
  
    - AIO(Asynchronous I/O)：异步I/O
  
      异步非阻塞的IO模型，异步IO是基于事件和回调机制实现的，应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续操作。对NIO来说业务线程在IO准备好时得到通知接着自行IO,IO本身是同步的。
  
- 浅拷贝与深拷贝

  浅拷贝：对基本类型进行值传递，对引用数据类型进行引用传递

  深拷贝：对基本数据类型进行值传递，对引用类型，创建一个新对象复制其内容。
  
- JDK 15新特性

  - 在CharSequence中添加isEmpty默认方法
  - 支持Unicode 13
  - TreeMap新方法
  - ZGC不在标记为实验功能，可在生产中使用
  - 模式匹配的instanceof

### 2. Java集合

- List,Set,Map 三者的区别

  - List（列表） ：存储的元素是有序的，可重复的
  - Set（集合）：存储的元素是无序的，不可重复的
  - Map（键值对）：存储键值对（key-value），key是无序的，不可重复的，value是无序的，可重复的

- ArrayList与LinkedList区别

  - 线程区别：ArrayList和LinkedList都是不同步的,不保证线程安全

  - 底层数据结构：ArrayList底层是Object数组，LinkedList底层使用的双向链表（JDK 1.6之前为循环的）

  - 插入和删除：ArrayList用数组存储，插入和删除元素时间复杂度受元素位置影响，在指定i位置插入或删除复杂度为O(n-i)

    LinkedList用链表存储，插入和删除都是O(1)

  - 快速随机访问：ArrayList支持快速随机访问，LinkedList不支持

  - 内存空间占用：ArrayList一般会在结尾预留一定容量的空间

    而Linked的每一个元素比ArrayList的消耗更多空间，前后指针

- 双向链表与循环双向链表

- RandomAccess接口 ：标识实现这个接口的类具有随机访问功能

- ArrayList 与 Vector

  ArrayList的默认大小是10

  ArrayList底层使用Object[]数组，适合频繁查找，线程不安全，每次扩容到自身的1.5倍，扩容操作需要调用 `Arrays.copyOf()` 把原数组整个复制到新数组中

  Vector底层使用Object[]数组，加了同步，线程安全，每次扩容到自身的2倍，Vector扩容可传入capacityIncrement参数

- ArrayList的扩容机制

  添加元素的时候使用ensureCapacityInternal()方法来保证容量足够，不够时，使用grow()方法扩容，新容量的大小为oldCapacity + oldCapacity>>1

  需要取整所以大约是1.5倍。扩容后调用ArrayList.copyOf()把原数组整个复制到新数组中。

- HashMap和HashTable区别

  - HashMap是非线程安全的，HashTable是线程安全的，因为HashTable内部的方法有Synchronized修饰

  - HashMap比HashTable效率高，HashTable基本被淘汰

  - HashMap可存储null的key和value，HashTable不允许有null
  - **HashMap初始容量16,每次扩容后变为原来的2倍**，HashTable初始容量11，之后每次扩容变为原来的2n+1
  - JDK 8之后，HashMap在链表长度大于阈值（默认是8）时，将链表转化为红黑树，以减少搜索时间。在转化为红黑树之前会判断当前数组长度，如果小于64那么会选择先扩容。

- HashMap和HashSet区别

  HashSet底层就是基于HashMap实现的

  一个实现Map存储键值对，一个实现Set存储对象

  HashMap使用Key计算hashcode,HashSet使用成员对象计算hashcode

- HashSet如何检查重复

  对象加入HashSet时HashSet先计算对象的hashcode，判断插入位置以及有没有相同的hashcode,如果有则调用equals()来判断

- HashMap的底层实现原理

  **JDK 1.8之前HashMap底层是数组和链表结合的链表散列**

  内部包含了一个 Entry 类型的数组 ，Entry 存储着键值对 ，是一个链表；

  put()：存放时，通过key的hashCode经过hash函数处理后得到hash值，然后通过(n-1)&hash判断当前元素存放的位置,当前位置存在元素就判断该元素与要存入的hash值以及key是否相同，单向链表的每个节点都进行比较，相同则覆盖，不同就用拉链法解决冲突,JDK 8 采用的是头插法

  get()：有一个节点的key与当前要查找的key的equals()方法返回true,取出value.

  **扩容原理**：

  ~~hashMap的长度为M,键值对为N,满足均匀性要求那么每条链表的长度约为N/M,查找复杂度O(N/M)，为降低查找成本，应该使N/M尽可能小。~~

  ~~capacity是table大小默认16，最大2的30次方。size是键值对数量，threshold是Size的临界值，loadFactor装载因子默认0.75f~~

  **需要扩容时，capacity为原来的两倍**。同样需要将oldTable的所有键值重新插入newTable，需要重新计算桶下标

- HashMap的长度为什么是2的幂次方

  为了让HashMap存取高效，尽量少碰撞。

  数据下标计算方法是(n-1)&hash，这是因为对2的幂取余 hash%n = (n-1)&hash

- HashMap多线程操作导致死循环问题

  并发下的rehash（扩容后重新hash）会造成元素之间形成一个循环链表

  JDK 1.8后解决了这个问题，不过还是存在数据丢失等问题。

- ConcurrentHashMap和HashTable的区别

  JDK1.8 以前，ConCurrentHashMap和HashMap实现上类似，最主要的差别是ConcurrentHashMap采用了分段锁（Segment），每个分段维护着几个桶，多线程可同时访问不同分段锁上的桶，从而使其并发更高。

  默认的并发级别为16，创建16个Segment

  到了JDK1.8时摒弃了Segment，直接使用Node数组+链表+红黑树的数据结构来实现，并发控制使用synchronized和CAS。

  HashTable底层数据结构采用是数组+链表的形式，使用Synchronized来保证线程安全，效率很低。当一个线程访问同步方法时，其他线程访问，可能会进入阻塞或轮询。

-  ConcurrentHashMap线程安全的具体实现方式/底层具体实现
  - JDK 1.8之前
  
    首先将数据分为一段一段的存储，然后每一段一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被访问
  
    ConcurrentHashMap是由Segment数组与HashEntry组成
  
    Segment实现了ReentrantLock，Segment是一种可重入锁
  
  - JDK 1.8之后
  
    ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构和HashMap类似，
  
    采用Node数组+链表，当链表长度超过一定阈值时将链表转化为红黑树
  
    **synchronized只锁定当前链表或红黑树的首节点，没有hash冲突就不会产生并发**
  
- LinkedHashMap

  继承自HashMap，也是数组，**不过内部维护一个双向链表**，用来维护插入顺序或LRU顺序，accesOrder决定了顺序，默认false,维护的是插入顺序

  afterNodeAccess()若accessOrder为True，当一个节点被访问后会将这个节点移到链表尾部，链表首部就是最近最久未使用的节点。

  put执行后，removeEldestEntry()返回true时会移除最晚的节点。

- 比较HashSet,LinkedHashSet和TreeSet三者的异同

  HashSet底层是HashMap，线程不安全可以存储null值；

  LinkedHashSet是HashSet的子类，能按照添加的顺序遍历；

  TreeSet底层使用红黑树，能按照添加元素的顺序进行遍历，有自然排序和定制排序

- 集合框架底层数据结构总结
  - List
    - ArrayList：Object[]数组
    - Vector：Object[] 数组
    - LinkedList：双向链表
  - Set
    - HashSet：基于HashMap实现，底层采用HashMap保存元素
    - LinkedHashSet：HashSet的子类，内部通过LinkedHashMap实现
    - TreeSet：红黑树
  - Map
    - HashMap：JDK 1.8之前由数组+链表组成，数组是HashMap的主体，链表主要为了解决哈希冲突，超过阈值转化为红黑树
    - LinkedHashMap：继承自HashMap,底层基本一样的，不过内部维护了一个双向链表，使得上面的结构可保持键值对的插入顺序
    - HashTable：数组+链表组成
    - TreeMap：红黑树

### 3. 多线程

#### 1.什么是线程和进程

- 进程：程序的一次执行，是**系统分配资源的基本单位**，运行程序就是一个进程从创建，运行到消亡的过程。PCB

- 线程：**独立调度的基本单位**，一个进程在执行时可产生多个线程，他们共享进程的资源。

  在Java中，多个线程共享进程的堆和方法区，但每个线程自己独占程序计数器，虚拟机栈和本地方法栈

- 简要描述线程和进程的关系，区别及优缺点

  在Java中，一个进程可以有多个线程，多个线程共享进程的堆和方法区，但每个线程自己独占程序计数器，虚拟机栈和本地方法栈

#### 2. 线程占用的位置

- 程序计数器为什么是私有

  程序计数器有两个作用：1. 字节码解释器通过改变程序计数器依次读取指令 2.在多线程情况下，程序计数器用于记录当前线程执行的位置。

  **为了线程切换后能恢复到正确的执行位置。**

- 虚拟机栈和本地方法栈为什么是私有的？

  虚拟机栈：每个Java方法在执行时会同时创建一个栈帧用于存储**局部变量表，操作数栈，常量池引用等信息**。方法调用直至执行完成，就对应一个栈帧在Java虚拟机中入栈和出栈的过程

  本地方法栈：虚拟机栈为Java方法服务，而本地方法栈为虚拟机使用的Native方法服务。HotSpot中合二为一

  **为了保证线程中的局部变量不被别的线程访问到**

- 堆和方法区

  **堆和方法区是所有线程共享的资源，堆是进程中最大的一块内存，主要用于存放新创建的对象**，**方法区用于存放被加载的类信息，常量，静态变量，即时编译后的代码**。

- 并发和并行

  并发：同一时间段，多个任务交替执行

  并行：同一时刻，多个任务都在执行

#### 3. 为什么要用多线程

- 线程是独立调度的基本单位，本身不占有资源或拥有很小的资源，调度的成本远小于进程。上下文切换开销小。

  多线程可以提高系统整体的并发能力，获得更高的性能

- 使用多线程可能带来什么问题？

  多线程可能导致：

  1.对共享数据的修改的**脏读**

  2.不正确的加锁或解锁可能导致**死锁**

  3.多线程的上下文切换会带来**额外的系统开销**

#### 4. 说说线程的生命周期和状态

**NEW（初始）-> 线程被构建，没有调用start()**

**RUNNABLE（运行）-> 操作系统的就绪和运行状态**

**[调用start后处于就绪状态，然后获取CPU的时间片就处于运行状态]**

**BLOCKED（阻塞）-> 线程未获得锁**

**[请求获得某个资源的锁却没有得到]**

**WAITING（等待）-> 线程需要其他线程唤醒**

**[线程执行wait()方法后]**

**TIME_WAITING（超时等待）-> 可以在指定时间内自行返回**

**[wait(),或sleep()时增加了时间限制]**

**TERMINATED（终止）-> 线程执行完毕**

**[执行Runnable的run()方法后]**

- 什么是上下文切换？

  CPU的一个核心某一时刻只能给一个线程使用，当一个线程获得了时间片就可运行，时间片用完就会重新处于就绪状态把CPU让给其他线程，CPU处理的线程的切换就上下文切换

#### 5. 什么是线程死锁，如何避免死锁？

- 死锁的定义

  一组进程中的每个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。

- 产生的原因

  竞争不可抢占性资源，竞争可消耗资源，进程推进顺序不当

- 死锁产生的四个必要条件

  互斥条件：资源任意时刻只有一个线程占用

  请求与保持：一个进程因请求资源而阻塞时不释放已获得的资源

  不可剥夺：线程持有的资源只能由自己释放

  循环等待：一组进程形成首尾相连的循环等待资源关系

- 如何避免死锁

  互斥条件无法破坏

  请求和保持条件：一次性申请所有需要的资源

  不可剥夺：请求的资源得不到时，释放已占有的资源

  循环等待：对系统的资源编号，申请资源需要按一定的顺序

#### 6. sleep()方法和wait()方法的区别与联系

- Sleep是Thread方法，wait是Object方法

  首先，**sleep()线程控制自身流程，wait()用来进行线程间通信**，使拥有该对象锁的线程等待制定时间或notify()；

  其次，**wait是让出对象锁，**并进入等待池，而sleep没有释放锁，因为它没有得到对象锁

  最后，**wait()必须放在同步块中**，而sleep()可在任何地方

  而且sleep必须捕获异常

- 为什么调用start()方法时会执行run(),为什么不能直接调用run()

  start()会执行线程相应的准备工作然后自动执行run()，启动线程并使其进入就绪状态。直接执行run()就只是main方法下的普通方法的执行，并不是多线程

#### 7. 对synchronized关键字的了解

- **解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行**

  监视器锁是依赖于底层的操作系统的MutexLock来实现的，Java的线程映射到操作系统的原生线程之上，挂起或者唤醒一个线程都需要操作系统帮忙。JAVA 6之后优化，对锁引入了大量的优化，例如自旋锁，适应性自旋锁，锁消除，锁粗化，偏向锁。等减少锁的开销。

  - 自旋锁

    自旋锁的思想是让一个线程在**请求一个共享数据的锁时执行忙循环**（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态

  - 锁消除

    锁消除是指对于被检测出**不可能存在竞争**的共享数据的锁进行消除

  - 锁粗化

    如果虚拟机探测到由这样的**一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部**

  - 偏向锁

    偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。

- 自己是怎么使用synchronized关键字的

  - 修饰实列方法：进入同步代码前要获得当前实例的锁

  - 修饰代码块：进入同步代码块前要获得给定对象的锁

    **以上作用域是同一对象**

  - 修饰静态方法：给当前类加锁，会作用于类的所有对象实例

  - 修饰类名：同步一个类，作用于类的所有对象实例

    **以上作用域是一个类**

    synchronized static void func(){}

    synchronized(a.class){}

    sychronized void func(){}

    synchronized(this){}

  - **单例模式**

    懒汉，饿汉，线程安全。。。。等[见设计模式]

- 构造方法可以使用synchronized关键字修饰么

  **构造方法不能使用sychronized关键字修饰**

  构造方法本身就是线程安全的，不存在同步构造方法。

- synchronized关键字的底层原理（语句块，方法）

  **同步语句块：**

  同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指令同步代码块开始位置，monitorexit指令指明同步代码块的结束位置。

  当执行monitorenter指令时，线程试图获取锁也就是获取对象监视器monitor的持有权。如果锁的计数器为0表示锁可以获取，获取后将计数器设置为1，在执行monitorexit指令后将锁计数器设置为0

  如果获取对象锁失败，当前线程就要阻塞等待，直到被另外一个线程释放为止。

  **同步方法：**

  修饰方法并没有monitorenter和monitorexit指令，取而代之的是ACC_SYNCHRONIZED标识，在进入该方法之前先获取相应的锁，锁的计数器加1，方法结束后计数器-1，如果获取失败就阻塞住，直到该锁被释放。

  **底层实现**：

  在JVM中，**对象是分成三部分存在的：对象头、实例数据、对齐填充**。

  **实例数据**存放**类的属性数据信息**，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐；

  **对齐填充**不是必须部分，由于虚拟机要求对象起始地址必须是8字节的整数倍，对齐填充仅仅是为了使字节对齐。

  **对象头**是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由`Mark Word` 和 `Class Metadata Address`组成，**其中**`Mark Word`**存储对象的hashCode、锁信息或分代年龄或GC标志等信息**，`Class Metadata Address`**是类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例**。

  锁也分不同状态，JDK6之前只有两个状态：无锁、有锁（重量级锁），而在JDK6之后对synchronized进行了优化，新增了两种状态：**无锁状态、偏向锁、轻量级锁、重量级锁**。锁的类型和状态在对象头`Mark Word`中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的`Mark Word`数据。

- 为什么要CPU高速缓存？

  **CPU缓存是为了解决CPU处理速度和内存处理速度不对等的问题，提高CPU的利用率**。

  先从内存复制一份数据到CPU Cache中，CPU需要用到的时候直接从CPU Cache中读取数据，运算完成后写回。

  存在内存缓存不一致性问题可以通过制定缓存一致协议解决

- JMM(Java Memory Model) Java内存模型

  JMM就是一组规则，意在解决并发编程可能出现的线程安全问题。JMM定义了程序中各个共享变量的访问规则，即在虚拟机中将变量存储到内存和从内存中读取变量这样的底层细节

  JDK1.2 之前，Java内存模型实现总是从主存（共享内存）读取变量。

  而现在的内存模型下，线程可以把变量保存在本地内存，而不是直接在主存中进行读写。然后通过主内存进行数据交换

  一个线程修改了主存的值，另一个线程不知道会造成数据的不一致。

  **Volatile**:通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。使用该变量，强制每次都到主存中读取。保证变量的可见性。

- synchronized与volatile关键字

  synchronized关键字和volatile关键字互补

  - volatile 是线程同步的轻量级实现，volatile性能比synchronized好。但volatile只能用于变量而synchronized可以修饰类，方法，以及代码块。
  - volatile能保证数据的可见性，但不能保证数据的原子性。synchronized两者都能保证
  - volatile解决变量在多个线程之间的可见性，synchronized解决多个线程之间访问资源的同步性

- **synchronized 与 reentralock 对比**

  - 锁的实现

    sychronized 是JVM实现的，而ReentrantLock是JDK实现的

  - 性能

    新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。

  - 等待可中断

    当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

    **ReentrantLock 可中断，而 synchronized 不行。**

  - 公平锁

    公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁

    sychronized中锁是非公平的，ReentrantLock默认情况是非公平的，但也可以是公平的

  - 绑定多个条件

    一个 ReentrantLock 可以同时绑定多个 Condition 对象。

  - 使用选择

    除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。

#### 8. ThreadLocal 【每个线程绑定自己的值】

ThreadLocal主要解决的是让每个线程绑定自己的值，存储每个线程的私有数据。

如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，可以用get(),set()方法获取默认值或将其改为当前线程的副本

- ThreadLocal原理

  Thread类中有一个threadLocals和inheritableThreadLocals变量，都是ThreadLocalMap类型的变量，线程调用ThreadLocal类的set或get时才创建。最终变量放在了当前线程的ThreadLocalMap中，并不是ThreadLocal上，ThreaLocal可理解为只是ThreadLocalMap的封装，key为当前对象的Thread对象，值为Object对象。传递了变量值。

- ThreadLocal内存泄漏

  ThreadLocalMap中使用的key为ThreadLocal的弱引用，而value是强引用。如果ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候，key会被清理掉，而value不会被清理掉。这样ThreadLocalMap就会出现key为null的Entry。假如不做任何措施的话，value永远无法被GC回收，就产生了内存泄漏。

  ThreadLocalMap在调用set()，get()，remove()方法时会清理掉key为null的记录。

  【**弱引用[下一次垃圾回收就收掉]**与**强引用[不会被回收]**】

#### 9. 线程池

- 为什么要用线程池？

  池化技术的思想主要是为了**减少每次获取资源的消耗，提高对资源的利用率**

  **线程池提供了一种限制和资源管理，每个线程池维护一些基本统计信息**

  **降低资源消耗。**通过重复利用已创建的线程降低线程创建和销毁造成的消耗

  **提高响应速度。**当任务到达时，任务可以不需要等到线程创建就能立即执行。

  **提高线程的可管理性。**使用线程池可进行统一分配，调度和监控

- 实现Runnable接口和Callable接口的区别

  Runnable接口不会返回结果或抛出异常，但是Callable接口可以。Excutors可以实现Runnable对象和Callable对象之间的转换

- 执行execute()方法和submit()方法区别是什么

  excute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否

  submit()用于提交需要返回值的任务。线程池会返回一个Furture类型的对象，通过这个对象可判断任务是否执行成功（可以通过Furture的get()来获取返回值）

- 如何创建线程池

  不使用Excutors去创建，而是通过ThreadPoolExecutor

  - FixedThreadPool 和 SingleThreadExecutor 允许请求的队列长度为MAX_VALUE，可能堆积大量的请求，导致OOM
  - CachedThreadPool : 允许创建线程的数量是MAX_VALUE

  1.通过ThreadPoolExecutor()构造方法实现

  2.通过Executor框架的工具类Executors来实现

  FixedThreadPool 返回一个固定线程数量的线程池

  SinglleThreadExecutor 返回一个只有一个线程的线程池

  CachedThreadPool 返回一个可根据实际情况调整数量的线程池

- ThreadPoolExecutor类分析

  - 参数分析
  
    corePoolSize: 核心线程数，定义了最小可同时运行的线程数量
    
    maximumPoolSize: 任务达到队列容量时，当前可同时运行的线程量变为最大数
    
    workQueue: 新任务在运行的线程数达到核心线程时放入队列
    
  - 饱和策略
  
    若当前同时运行的线程数量达到最大线程数量且队列也已经放慢了任务时，ThreadPoolTaskExecutor定义如下策略：
  
    **AbortPolicy**:抛异常拒绝处理新任务
  
    **CallerRunsPolicy**: 调用执行自己的线程运行任务。不会任务请求。忍受延迟并不丢弃任何一个任务请求。
  
    **DiscardPolicy**:不处理新任务，直接丢弃掉
  
    **DiscardOldestPolicy:** 丢弃最早的未处理的任务请求
  
- 线程池原理分析

  - 配置核心线程数为5，等待队列容量100，每次只能存在5个任务同时执行，剩下5个任务会被放到等待队列中。当前任务执行完后执行剩下的

#### 10. 介绍一下Atomic原子类

- 一个操作是不可中断的，即使在多线程一起执行的时候，一个操作一旦开始就不会被其他线程干扰

  原子类具有原子/原子操作特征的类，不可分割

  java.util.concurrent 的原子类都在java.util.concurrent.atomic下

- JUC中的原子类是哪4类？

  - **基本类型**：AtomicInteger, AtomicLong, AtomicBoolean
  - **数组类型**：AtomicIntegerArray,AtomicLongArray,AtomicReferenceArray
  - **引用类型**：AtomicReference,AtomicStrampedReference,AtomicMarkableReference
  - **对象的属性修改类型**：AtomicIntegerFieldUpdater,AtomicLongFieldUpdater,AtomicReferenceFieldUpdater,

#### 11. AQS

- AbstractQueueSynchronizer

  **是一个用来构建锁同步器的框架**，使用AQS能简单且高效地构造出广泛的大量的同步器，如RentrantLock,Semaphore等

- 原理

  如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么需要一套线程阻塞等待以及被唤醒时锁分配机制，AQS用CLH（虚拟双向队列）队列锁实现，将暂时获取不到锁的线程加入到队列中。

  AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改

- 对资源的共享方式

  - Exclusive（独占）

    只有一个线程能执行，如ReentrantLock，又分公平锁和非公平锁

  - Share（共享）

    多个线程可同时执行，如CountDownLatch,Semaphore

  - 自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可

- AQS底层使用了模板方法模式

  - 使用继承AQS并重写指定方法。
  - 将AQS组合在自定义同步组件的实现中，并调用模板方法

- **模板方法模式**

  - 定义一个操作中**算法的框架**，而**将一些步骤延迟到子类中**。模板方法模式使得子类不改变一个算法的结构即可**重定义**该算法的**某些特定步骤**
  - 基于继承的代码复用
  - 子类实现详细的处理算法时不会改变算法中步骤的执行次序，符合单一职责原则，开闭原则
  - 用钩子反向控制
  - **适用**：一次性实现算法中不变的部分，可变行为留给子类

- AQS组件总结

  - Semaphore -允许多个线程同时访问，synchronized和reentrantLock都是一次只允许一个线程访问某个资源

  - countDownLatch - 用来控制或者多个线程等待多个线程。维护一个计数器cnt，每次调用countDown()方法会让计数器值减1，到0时，调用await()方法等待的线程会被唤醒

  - CyclicBarrier - 控制多个线程相互等待，当多个线程都到达时这些线程才会继续执行。与CountdownLatch()类似，都是维护计数器来实现。

    计数器可以调用reset()方法循环使用，循环屏障

- CountDownLatch在什么场景下用？

  - CountDownLatch作用是允许count个线程阻塞在一个地方，直至所有线程的任务都执行完。
  - 使用多线程读取多个文件时可以用，定义一个线程池和count为5的CountDownLatch对象，用线程池处理读取任务，每一个线程处理完后count-1,调用对象的await()方法，知道所有文件读取完才执行后面的逻辑
  - 改进：使用CompletableFuture类来改进

### 4. JVM

#### 1. 介绍下Java内存区域

- JVM在执行Java程序的过程中会把它管理的内存划分为若干不同的数据区域

  JDK1.8 之前：

  - 线程共享的**堆和方法区**，方法区有的运行时常量池
  - 线程私有的**虚拟机栈，本地方法栈，程序计数器**
  - **直接内存**

  JDK1.8开始：

  - 将方法区变成了元空间Metaspace，放在直接内存

- **程序计数器**

  一块较小的内存空间，可看作当前线程所执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。为了线程切换后恢复到正确位置，每个线程都要有一个独立的程序计数器，记录当前位置。

  唯一一个不会出现OOM的内存区域，生命周期随着线程创建而创建，随着线程结束而死亡

- Java虚拟机栈

  与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，**描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的**。

  Java内存可区分为堆内存和栈内存。

  虚拟机栈由一个个栈帧组成，每个栈帧都有局部变量表，操作数栈。。。

  局部变量表主要存放了编译器可知的各种数据类型

  Java虚拟机会出现两种错误：StackOverFlowError和OutOfMemoryError

  **StackOverFlowError**: 若Java虚拟机栈的内存大小不允许动态扩展，当前线程请求栈的深度超过当前虚拟机栈的最大深度时，就会抛出StackOverFlowError

  **OutMemoryError**: 若虚拟机栈中没有空闲内存，且垃圾回收器无法提供更多的内存，就会抛出OutOfMemoryError

  **方法如何调用**

  Java栈保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧压入Java栈，调用结束后都会有一个栈帧被弹出。Java方法两种返回方式：return语句，抛出异常

- **本地方法栈**

  和虚拟机栈所发挥的作用相似，虚拟机栈执行Java方法服务，本地方法栈为虚拟机使用到Native方法服务。HotSpot虚拟机中合二为一

- **堆**！！！！！

  Java虚拟机所管理的内存中最大的一块，所有线程共享。此区域的唯一目的就是存放对象实例，几乎所有对象实例以及数组都在这里分配内存

  jdk1.7开始默认开启逃逸分析，某些方法中的对象引用没有被返回或者未被外面使用，那对象可直接在栈上分配内存

  **Java堆是垃圾收集器管理的主要区域，由于收集器基本都采用分代垃圾收集算法，所以Java堆可细分为新生代和老年代，再细致一点有Eden,FromSurvivor,ToSurvivor空间，进一步划分的目的是更好地回收内存，更快分配内存**。

  JDK7之前，堆内存通常被分为下面三部分：

  新生代，老年代，永生代

  JDK8之后，HotSpot的永久代被彻底移除了，取而代之的是元空间

  大部分对象都会首先在Eden区域分配，在一次新生代垃圾回收后，对象还活着会进入s0或s1，且对象年龄+1，年龄增加到一定程度（默认15）就会晋升到老年代。

  （Hotspot遍历所有对象时，按年龄大小从小到大对其所占用的大小进行累积，累积的某个年龄大小超过survivor一半时取年龄和MaxTenuringThreshold中更小的一个值作为晋升的年龄阈值）

  堆这里最容易出现OOM,OOM的几种表现形式：

  - OutOfMemoryError: JVM花太多时间执行垃圾回收并只能回收很少的堆空间时，就会发生此错误

    GC Overhead Limit Exceeded

  - OutOfMemoryError: java heap space 假如在创建新的对象时，堆内存中的空间不足以存放新创建的对象，就会引发这个错误。

- 方法区

  方法区与Java堆一样，是各个线程共享的内存区域，用于**存储已被虚拟机加载的类信息，常量，静态变量，即时编译后的代码**等数据。

  Java虚拟机规范把方法区描述为堆的一个逻辑部分

  方法区也被称为永久代。《Java虚拟机规范》只是规定了有方法区这个概念和它的作用，并没规定如何去实现。**永久代就是HotSpot虚拟机对方法区的一种实现方式**。一个是标准一个是实现。

  JDK 1.8 之前，通过以下参数来调节方法区的大小:persize, MaxPerSize

  JDK 1.8之后，方法区被彻底移除，取而代之的是元空间，使用直接内存

  MetaSpaceSize和MaxMetaSpaceSize

  与永久代不同，如果不指定大小的话，随着更多类创建，虚拟机会耗尽所有可用的系统内存

- 为什么将永久代(PerGen)换为元空间(MetaSpace)

  - **整个永久代有一个JVM本身设置固定大小上限，无法进行调整**，元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，几率变小了
  - 元空间里面存放的是类的元数据，由系统实际可用空间来控制，能加载的类就更多了

- 运行时常量池

  是方法区的一部分，当常量池无法再申请到内存时会抛出OutOfMemoryError

  JDK 1.8 中字符串常量池还在堆中，运行时常量池还在方法区，不过方法区的实现变成元数据

- 直接内存

  不是虚拟机运行时数据区的一部分，也不是虚拟机规范定义的内存区域。

  但这部分也被频繁使用，且也可能导致OutOfMemory错误

  NIO引入一种基于通道与缓存区的I/O方式，它可直接使用Native函数库直接分配堆外内存，然后通过Java堆中的DirectByteBuffer作为这块内存的引用进行操作，避免来回复制

#### 2. Java对象的创建过程

- Step 1: **类加载检查**

  虚拟机遇到一条new指令时，首先将去检查~~这个指令的参数~~是否能在常量池中**定位到这个类的符号引用，并检查这个符号引用代表的类是否被加载过，解析和初始化**。没有则必须先执行相应的类加载过程

- Step 2: **分配内存**

  类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载后确定，**为对象分配空间等于把一块确定大小的内存从Java堆中划分出来**。分配方式有“指针碰撞”和“空闲列表”两种，选择哪种方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定

  采用标记-清除不规整，采用标记-整理，复制则规整

  **指针碰撞（堆内存规整）**：用过和没用过的内存各放一边，中间有分界指针，只需向没用过的内存方向将该指针移动到内存大小位置即可。Serial,ParNew

  **空闲链表（堆内存不规整）**：维护一个列表记录哪些内存块可用，分配时找一个足够大的分配，然后更新记录。CMS

  创建对象时很重要的问题就是线程安全，虚拟机采用两种方式来保证线程安全：

  - CAS+失败重试：CAS是乐观锁的一种实现方式，虚拟机用CAS+失败重试来保证更新操作的原子性

  - TLAB: 为每一个线程预先在Eden分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或TLAB的内存已用尽时用上述的CAS进行内存分配。

  - CAS

    比较并交换(compare and swap, CAS)，是原子操作的一种，**可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题**。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。

  - **悲观锁**：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样当第二个线程想拿这个数据的时候，第二个线程会一直堵塞，直到第一个释放锁，他拿到锁后才可以访问。传统的数据库里面就用到了这种锁机制，例如：行锁，表锁，读锁，写锁，都是在操作前先上锁。java中的synchronized的实现也是一种悲观锁。

    **乐观锁**：乐观锁概念为，每次拿数据的时候都认为别的线程不会修改这个数据，所以不会上锁，**但是在更新的时候会判断一下在此期间别的线程有没有修改过数据**，乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。在Java中java.util.concurrent.atomic包下面的原子变量就是使用了乐观锁的一种实现方式CAS实现。

- Step 3: **初始化零值**

  内存分配完成后，**虚拟机将分配到的内存空间都初始化为零值，这样保证了对象实例字段在Java字段中可不赋初始值就直接使用**，程序能访问到这些字段的数据类型对应的零值。

- Step 4: **设置对象头**

  初始化零值完成后，**虚拟机对对象做必要的设置，例如这个对象是哪个类的实例**，如何才能找到类的元数据信息，对象的哈希码。这些信息放在对象头中。

- Step 5: **执行init方法**

  从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序视角来看对象创建才刚开始，**执行new指令后接着执行<init>方法**，按程序的意愿进行初始化。

#### 3. 对象访问定位

通过栈上的reference数据来操作堆上的具体对象。对象的访问方式有：

1. 句柄

   使用句柄的话Java堆中会划分出一块内存作为句柄池，reference存储的就是对象的句柄地址，包含了对象实例数据与类型数据各自的具体地址信息

2. 直接指针

   如果使用直接指针访问，那么Java堆对象必须考虑如何防止访问类型相关数据的相关信息，reference中存储的直接就是对象的地址。

这两种对象访问方式各有优势，句柄：对象被移动时只会改变句柄中实例数据指针，reference本身不需要修改；直接指针访问就是速度快，节省了一次指针定位的时间开销

#### 4. JVM内存分配与回收

Java堆是垃圾收集器管理的主要区域，也称为GC堆，从垃圾回收的角度，采用分代垃圾收集算法，Java堆还能细分为：新生代，老年代，新生代还能细分为：Eden,From Survivor , To Survivor

大部分情况，对象都会先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或s1,且对象的年龄还会+1，年龄增加到一定程度（默认15）就会晋升到老年代。

HotSpot遍历所有对象时按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄超过了survivor的一半时，取这个年龄和MaxTenuingThreshold中更小的一个值作为阈值

经过这次GC后，Eden区和From Survivor区已被清空，From和To会交换他们的角色。Minor GC一直重复这样的过程，直到“To”区被填满，将所有对象移动到老年代中。

#### 5. 堆内存中对象分配的策略

对象优先分配在Eden，大对象直接进入老年代，长期存活的对象将进入老年代 

- 对象优先分配在Eden

  大多数情况下，对象在新生代中Eden区分配。当Eden区没有足够空间分配时，虚拟机将发起一次Minor GC

  如果无法存入Survivor空间的话通过分配担保机制把新生代对象提前转移到老年代

  老年代空间足够的话就不会出现Full GC

- 大对象直接进入老年代

  大对象是需要大量连续内存空间的对象（字符串，数组等）

  **为了避免大对象分配内存时由于分配担保机制带来的复制而降低效率**

- 长期存活的对象将进入老年代

  虚拟机给每个对象一个对象年龄计数器

  先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或s1,且对象的年龄还会+1，年龄增加到一定程度（默认15）就会晋升到老年代。

- 动态对象年龄判定

#### 6. 主要进行GC的区域

针对HotSpot VM的实现，GC准确分类两大种

- 部分收集（Partial GC）

  新生代收集（Minor GC/Young GC）:只对新生代进行垃圾收集

  老年代收集（Major GC/Old GC）：只对老年代进行垃圾收集，有时Major GC也指整堆收集

- 整堆收集（Full GC）:对整个Java堆和方法区进行垃圾回收

#### 7. 如何判断对象是否死亡

- 引用计数法

  给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；

  当引用失效时，计数器就减1.计数器为0的对象就是不可能再被使用的

- 可达性分析

  通过一系列称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点走过的路径为引用链，当一个对象到GC Roots没有任何引用链则说明此对象是不可用的
  
  - 可作为GC Roots的对象
    - 虚拟机栈，本地方法栈中引用的对象
    - 方法区中常量，静态变量

#### 8. 介绍强引用，弱引用，软引用，虚引用

JDK1.2 之前，Java中引用定义：reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用

- 强引用（StrongReference）

  被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。

- 软引用（SoftReference）

  被软引用关联的对象只有在内存不够的情况下才会被回收。使用SoftReference类来创建软引用

- 弱引用

  被弱引用关联的对象一定会被回收，也就是只能存活到下一次垃圾回收发生之前，使用WeakReference 来创建弱引入

- 虚引用

  又称为幽灵引用或幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象

  设置虚引用的唯一目的就是能在这个对象被回收时收到一个系统通知

  PhantomReference

- 虚引用，软引用，弱引用

  虚引用必须和引用队列联合使用，垃圾回收器准备回收一个对象时，若发现它还有虚引用，在回收对象的内存前把这个虚引用加入到与之关联的引用队列中。若某个虚引用已经被加入到引用队列，那可在所引用的对象的内存被回收前采取必要的行动。

  软引用可以加速JVM对垃圾的回收速度，维护系统的安全，防止内存溢出（OOM）

#### 9. 如何判断一个常量是废弃常量

运行常量池主要回收的是废弃的常量

对字符串常量而言，如果没有任何String对象引用该字符串常量，说明该常量是废弃常量。

#### 10. 如何判断一个类是无用的类

- 该类的**所有实例都已经被回收**，Java堆中不存在该类的任何实例
- **加载该类的ClassLoader已经被回收**
- **该类对应的java.lang.class对象没有在任何地方被引用**，无法通过反射访问该类的方法

#### 11. 垃圾收集有哪些算法，各自的特点

- 标记-清除算法

  首先标记出所有不需要回收的对象（活动的对象），在清除阶段，标记完成后统一回收掉所有没被标记的对象。还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表

  **效率低且标记清除后会产生大量不连续的碎片**

- 复制算法

  将内存分为大小相同的两块，每次使用其中的一块，当这一块内存使用完后就将还存活的对象复制到另一块去，然后把使用的空间一次清理掉。

  每次的内存回收都是对内存区间的一半进行回收。

- 标记-整理算法

  根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续是让所有存活的对象向一端移动，然后清理掉边界以外的内存。

- 分代收集算法

  新生代中每次收集都会有大量对象死去，可选择复制算法，只需付出少量对象的复制成本就可以完成每次垃圾回收。

  老年代的对象存活几率是比较高的，且没有额外的空间对它担保，所以必须选择“标记-清除”或“标记-整理”

#### 12. HotSpot为什么要分为新生代和老年代？

主要是为了提升GC效率，分代收集算法。

#### 13. 常见的垃圾回收器有哪些？

收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现

根据具体场景选择适合的垃圾收集器

- Serial收集器

  Serial串行收集器是最基本，历史最悠久的垃圾收集器，它的“单线程”不仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，进行垃圾收集时必须暂停其他所有工作线程（Stop the World）

  **新生代：复制算法，老年代：标记-整理算法**

  简单而高效，对Client模式下的虚拟机来说是不错的选择

- ParNew 收集器

  Serial收集器的多线程版本，除了使用多线程外，其他参数（控制参数，收集算法，回收策略等）一样

  **新生代：复制算法，老年代：标记-整理算法**

  运行在Server模式下的虚拟机的首要选择，只有它能与CMS配合工作。

  并行：多个线程在同一时刻运行

  并发：一段时间内，线程交替执行

- Parallel Scavenge收集器

  多线程收集器，看上去与ParNew一样

  Parallel Scavenge收集器关注的是吞吐量（高效率的利用CPU）

  CMS关注的是用户线程停顿时间（提高用户体验）

  提供了很多参数供用户找到最适合的停顿时间或最大吞吐量

  **新生代：复制算法，老年代：标记-整理算法**

  JDK 1.8 默认使用 Parallel Scavenge + Parallel Old

- Serial Old收集器

  Serial 收集器的老年代版本，单线程

  在JDK 1.5前与Parallel Scavenge收集器搭配使用，还可作为CMS的后备

- Parrellel Old收集器

  Parallel Scavenge的老年代版本，使用多线程的“标记-整理”算法，注重吞吐量以及CPU的场合可优先考虑

- CMS收集器

  CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收时间为目标的收集器.是HotSpot上第一款真正意义上的并发收集器，实现了让垃圾收集线程与用户线程基本同时工作

  - 初始标记：暂停所有其他线程，记录直接与root连的对象
  - 并发标记：开启GC和用户线程，闭包记录可达对象
  - 重新标记：修正并发标记期间因用户继续运行导致标记变动的那部分
  - 并发清除：开启用户线程，GC对未标记的地区清扫

  优点是并发收集，低停顿；

  缺点是 对CPU资源敏感；无法处理浮动垃圾；回收-标记算法导致空间碎片

- G1收集器

  G1是一款面向服务器的垃圾收集器，主要针对配备多处理器以及大容量内存的机器，以极高的概率满足GC停顿时间要求，还具备高吞吐量

  - 并发与并行：充分利用CPU,多核环境下的硬件优势缩短Stop-The-World时间
  - 分代收集：不需要配合其他收集器，但保留了分代的概念
  - 空间整合：G1整体上基于“标记-整理”算法实现的收集器，局部上基于“复制”算法实现

  G1在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region.

  运作的大致步骤：

  - 初始标记
  - 并发标记
  - 最终标记
  - 筛选回收

- ZGC收集器

  与G1类似，ZGC采用标记-复制算法，ZGC在标记，转移和重定位阶段几乎都是并发的，ZGC实现停顿时间小于10ms的关键原因

  - 初始化
  - 并发标记
  - 并发转移

  ZGC通过着色指针和读屏障，解决了转移过程中准确访问对象的问题

## 2. 计算机网络

#### 1.OSI的七层模型，TCP/IP的四层模型，五层模型

- **七层**：物理层，数据链路层，网络层，运输层，会话层，表示层，应用层

  - 物理层：机械，电子，定时接口通信信道上的原始比特流传输

    协议：IEEE 802.2 Ethernet v2

    设备：集线器，中继器

  - 数据链路层：物理寻址，同时将数据封装成帧，控制帧在物理信道上的传输

    协议：ARP,RARP,PPP，HDLC

    设备：网桥，交换机

  - 网络层：分组传输，路由选择，为主机之间提供数据传输服务，为分组通过通信子网选择最适当的路径，以实现网络的互连功能

    协议：RIP,OSPF,BGP,IP,ICMP

    设备：路由器,第三层交换机

  - 传输层：两主机的进程之间的通信提供通用的数据传输服务

    协议：TCP,UDP

  - 会话层：不同主机的用户之间的会话的建立和管理

    协议：SSL安全套接字协议，TLS传输层安全协议

  - 表示层：信息的语法语义以及它们的关联，加解密等

  - 应用层：通过应用之间的交互来完成特定网络

    协议：HTTP,FTP，TELNET,POP3，IMAP,DNS

- **TCP/IP四层**：网络接口层，网际层，运输层，应用层

- **五层**

  - 应用层：通过应用间的交互来完成特定网络应用
    - DNS（Domain Name Sysytem）

      将域名解析为IP地址的分布式数据库。

    - HTTP

      是一个请求响应协议，通常运行在TCP上，规定了服务器端与客户端的交互规则。

  - 运输层：向两台主机进程之间的通信提供通用的数据传输服务

    - TCP
    - UDP

  - 网络层：为主机提供数据传输服务。

  - 数据链路层：主机之间有很多链路，数据链路层协议就是为同一链路的主机提供数据传输服务

  - 物理层：怎样在传输媒体上透明地传输比特流，尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异

- TCP三次握手[防止失效的请求报文，让服务器错误打开连接]

  - 第一次握手：客户端向服务器端发送带有SYN标志的数据包

  - 第二次握手：服务器端如果同意建立连接，则向客户端发送带有SYN/ACK标志的数据包

  - 第三次握手：客户端收到连接确认报文后，还要向服务器端发出ACK确认报文

    **三次握手是为了确认双方的接收和发送是正常的，第三次握手是为了防止网络中失效的请求报文让服务器错误打开**

    客户端发送的连接请求如果在网络中滞留，那么很长一段时间后才能收到服务器端发回的连接确认。客户端等待一个超时重传时间后就会再发送一次请求，这个请求到达服务器后，不进行三次握手就会打开两个连接
    
    SYN: 是TCP/IP建立连接时使用的握手信号，接收端传回所发送的SYN是为了告诉发送端，接收到的信息就是你所发送的
    
    SYN还要ACK？：双方通信无误必须是两者互相发送消息都无误。SYN,发送方到接收方没问题，ACK，反过来
    
    

- TCP四次挥手：TIME_WAIT —> 2MSL- [最后一个确认报文到达，让本次连接的所有报文消失]

  - 第一次：客户端发送一个FIN，连接释放报文

  - 第二次：服务器端收到后发送ACK,此时TCP处于半关闭状态，服务器端能发送，而客户端不行

  - 第三次：当服务器端不再需要发送数据时，发送连接释放报文，FIN =1

  - 第四次：客户端收到后发送ACK确认，等待2个最大报文存活时间后释放连接，服务器端收到后也释放

    任何一方都可以在数据传送结束后发出连接释放请求，对方确认后进入半关闭。当另一方也没有数据发送时，连接释放，TCP连接关闭

    客户端接收到服务器的FIN报文等待2MSL才CLOSED：

    - 确认最后一个确认报文能到达。若服务器端没收到客户端发送的确认报文就会重新发送连接释放请求报文
    - 让本次连接持续时间内所有报文消失在网络中，下一个连接不会收到影响

- TCP和UDP的区别

  **TCP：面向连接的，可靠的，字节流传输，传输效率低，所需资源多，首部20-60字节**

  **UDP：无连接的，不可靠的，数据报文段传输。传输效率低，所需资源少。首部8个字节**

  UDP在传送数据之前不需要先建立连接，收到UDP报文后也不需要给出确认。虽然UDP不可靠，但某些情况下，UDP是一种有效的工作方式，语音，视频，直播等。

  TCP提供面向连接的服务，在传送数据前必须先建立连接，传送完后释放连接。在数据传递时有确认，窗口，请求重传，拥塞控制等机制，增加了许多开销。一般用于文件传输，邮件，远程登录等

- TCP如何保证可靠传输的？[校验和，流量控制，拥塞控制，ARQ，超时重传]

  - 校验和：TCP保持首部和数据部分的校验和。检测数据在传输过程中有没有发生变化
  - 流量控制：TCP通信双方有接收窗口和发送窗口，当接收方来不及处理发送方的数据，提示发送方降低发送速率
  - 拥塞控制：网络发生拥塞时减少数据的发送
  - ARQ自动重传请求：每发送一个分组就停止，等待对方确认后再发送下一组。如果在一定时间内没有收到确认就重发。

- ARQ(自动重传请求)协议[停止-等待ARQ协议，连续ARQ协议]

  - 停止-等待ARQ
    - 发送一个分组就停止，等待对方确认，过了一段时间，还是没收到ACK确认说明发送失败，重新发送直到收到确认后发送下一组
    - 停止-等待，接收方收到重复分组就丢弃并发送确认
  - 连续ARQ
    - 发送方维持一个发送窗口，凡是位于发送窗口内的分组可以连续发送出去，而不需等待对方确认。接收方一般采取累计确认，对按序到达的最后一个分组发送确认，表明这个分组前的所有分组都已经正确收到了
    - 利用率高，容易实现，但不能反映接收方已正确收到的所有分组信息

- 滑动窗口和流量控制

  **TCP利用滑动窗口实现流量控制。流量控制是为了控制发送方速率保证接收方来得及接收。**接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小从而影响发送方速率。

- 拥塞控制[慢开始，拥塞避免，快重传，快恢复]

  **若对网络中的某一资源的需求超过了对该资源能提供的可用部分，网络的性能下降。就是拥塞。**

  拥塞控制是为了防止过多的数据注入到网络，防止网络中的路由器或链路过载。

  **拥塞控制是一个全局的过程，涉及网络中所有主机，路由器，以及与降低传输性能有关的所有因素。**

  **流量控制是点对点通信量的控制，是一个端到端的问题，抑制发送端发送速率**

  TCP发送方需要维护一个拥塞窗口cwnd的状态变量；

  拥塞窗口是一个状态变量，实际决定发送方能发送多少数据的是发送窗口

  - 慢开始：主机刚开始发送数据时，立即把大量数据注入到网络可能会引起网络阻塞。cwnd初始值为1，每经过一个传播轮次，cwnd加倍

  - 拥塞避免：cwnd缓慢增大，即每经过一个往返时间RTT就把cwnd加1

  - 快重传与快恢复：

    如果接收方收到3个重复确认，就知道接收方没有收到报文，就会立即重传，不会被重传时间限制

- 在浏览器输入URL地址，显示主页的过程

  首先，浏览器查找域名对应的IP地址。依次查找浏览器缓存，路由器缓存，DNS缓存。使用的是DNS协议，有迭代查询和递归查询

  然后，浏览器获得域名对应的IP地址后，浏览器向服务器请求建立连接。使用的是TCP

  然后，连接建立后发送HTTP请求，服务器处理请求并响应HTTP报文。

  客户端收到进行解析并渲染视图，遇到js，css等静态资源引用则重复上述步骤并向浏览器请求这些资源。

  使用的长连接就不用重新建立TCP,短连接则需要

  使用了DNS，TCP,IP,OSPF(IP数据包在路由器之间传送数据)，ARP,HTTP

- 状态码（1XX,2XX,3XX,4XX,5XX）

  1XX 信息性状态码- 接收的请求正在处理 100 Continue

  2XX 成功状态码- 请求正常处理完毕 204 No Content,206 Partial Content

  3XX 重定向状态码- 需要进行附加操作以完成请求 301 永久重定向 ，302暂时重定向

  - 我们在网站建设中，时常会遇到需要网页重定向的情况：

    1.网站调整（如改变网页目录结构)）；

    2.网页被移到一个新地址；

    3.网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 

  4XX 客户端错误状态码 -服务器无法处理请求 400,401 Unauthorized,403,404

  5XX 服务器错误状态码 -服务器处理请求出错 500 ,503

- HTTP长连接与短连接

  当浏览器访问一个包含很多图片的HTML页面时，除了请求访问的HTML资源还会请求图片资源，需要多次HTTP请求；

  短连接每进行一次HTTP请求就新建一个TCP连接，开销很大

  长连接只需要建立一次TCP连接就能多次HTTP通信

  HTTP 1.1开始默认长连接，断开连接需要由客户端或服务器端提出。

  HTTP 1.1之前默认短连接

- HTTP是不保存状态的协议，如何保存用户状态？[Session, Cookie]

  HTTP是无状态的，主要是为了让HTTP协议尽可能简单，使它能处理大量事务。

  HTTP 1.1引入Cookie来保存状态信息

  **cookie是服务器端发送到客户端并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带，**用于告知服务器端是否来自同一浏览器。可以用来保存用户信息，下一次自动填充。个性化，行为跟踪

  cookie渐渐被淘汰，新的浏览器API已允许直接存在本地

  **Session主要作用就是通过服务器端记录用户的状态，服务器端给特定的用户创建特定的Session之后就可以标识某个用户并跟踪了**。服务器端可以将Session保存在服务器的文件，数据库或内存。Redis效率高

  实现Session通过在Cookie中添加一个Session ID，若禁用了Cookie,就放在URL后面

- Cookie的作用是什么？和Session有什么区别？

  Cookie保存在客户端，Session保存在服务器端，Session安全性更高

  Cookie只能存储ASCII码字符串，Session能存储任何类型数据

  大型网站用户信息都存在Session中开销很大

- HTTP1.0 和 HTTP1.1的主要区别[长连接，错误状态响应码，缓存处理，206 Partial]

  - 长连接：在HTTP 1.0中默认使用短连接，HTTP1.1起默认长
  - 错误状态响应码：在HTTP1.1中新增了很多错误状态响应码，如409 请求的资源与资源当前的状态发生冲突
  - 缓存处理：在HTTP1.0中主要用header里的if-modified-since来作为标准，1.1引入了更多的缓存控制策略，如If-Match
  - 优化：请求头加入range,允许请求资源的某个部分，返回码206

- URI和URL区别

  URI是统一资源标识符，唯一标识某一个资源

  URL是统一资源定位符，提供了该资源的路径。标识一个资源并指明如何定位

- HTTP与HTTPS

  首先，HTTP默认使用的是80端口，HTTPS默认使用443端口

  然后，就是安全性

  HTTP使用明文通信，不验证通信方身份，无法证明报文的完整性

  HTTP先和SSL通信，再由SSL和TCP通信，HTTPS使用了隧道

  从而具有了加密，认证和完整性保护，但耗费了更多的服务器资源

  （对称：加密和解密使用同一密钥，非对称：加密和解密使用不同密钥）

  HTTPS使用的是混合加密，先使用非对称加密传输密钥加密方式需要的Secret Key，保证安全性，获取到Secret Key后使用对称加密方式通信，保证效率

## 3. 操作系统

- 什么是操作系统

  管理计算机硬件与软件资源的程序，为应用程序屏蔽了底层硬件的复杂性

  基本特征：并发，共享，虚拟，异步

  基本功能：进程管理，内存管理，文件管理，设备管理

- 什么是系统调用

  如果一个进程在用户态需要使用内核态的功能，就要进行系统调用，由操作系统代为完成

  用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作

  用户态：用户进程是受限的，不能随意访问或获取资源，一个进程在执行用户自己的代码时处于用户态

  内核态：权限等级最高的状态，可以执行任何CPU指令，引用任何内存地址

  - 系统调用
  - 异常
  - 外围设备中断

- 中断分类

  - 外中断：CPU执行指令以外的事件引起，如IO中断
  - 异常：也叫内中断，CPU执行指令的内部事件引起，如非法操作码，地址越界等

- 进程和线程之间的关系

  进程是资源分配的基本单位，进程控制块PCB描述进程的基本信息和状态

  线程是独立调度的基本单位，一个进程中可以有多个线程，他们共享进程资源

- 进程有几种状态

  **创建状态**：被创建了

  **就绪状态**：进程已经准备好了，获得了除了处理器以外的一切资源，一旦获得了时间片就可以运行

  **运行状态**：进程正在处理器上运行（）

  **阻塞状态**：等待某一事件完成而暂停运行

  **结束状态**：消失在系统中

  就绪 -> 运行，运行->就绪，运行 -> 阻塞 -> 就绪

- 进程间的通信方式 [管道，FIFO(命名管道)，消息队列，信号量，共享存储，套接字]

  管道：父子进程或兄弟进程之间的通信，半双工

  有名管道：匿名管道由于没名字只能兄弟，父子。以磁盘文件的方式存在，可实现本机任意两进程通信。

  信号量：是一个计数器，为多个进程提供对共享数据对象的访问

  消息队列：可以独立于读写进程而存在，不需要进程提供同步方法

  读进程可以根据消息类型有选择地接收消息

  共享内存：多个进程访问同一块内存空间，不同进程能看到其他对共享内存中数据的修改

  套接字：网络上不同主机之间的进程的通信，TCP/IP网络通信的操作单元

- 线程同步[互斥量，信号量，事件]

  临界区：访问临界资源的那段代码

  同步：多个进程因合作产生的直接制约关系，进程有一定的先后执行

  互斥：多个进程在同一时刻只有一个能进入临界区

  

  信号量：整型变量，允许同一时刻多个线程访问一类资源

  互斥量：整型变量为1时，信号量就成了互斥量

  事件：通过通知操作的方式保持多线程同步，还可方便地实现多线程的优先级

- 进程调度算法[FCFS,SJF,时间片轮转，多级反馈队列，优先级调度]

  - FCFS(先到先服务)：就绪队列选一个最新进入的进程分配资源，执行到完成或发生某事而阻塞放弃占用CPU再重新调度
  - SJF(短作业优先)：从就绪队列中选一个估计运行时间最短的进程为之分配资源
  - 时间片轮转：按FCFS排成一个队列，每次调度时把CPU时间分配给队首进程
  - 优先级调度：为每个进程分配一个优先级
  - 多级反馈队列调度：每个队列的时间片的大小不同

- 内存管理机制[分配与回收，逻辑地址与物理地址的转换]

  主要负责内存的分配与回收，实现虚拟内存，完成逻辑地址到物理地址的转换

- 常见的几种内存管理方式[块式，分页，分段，段页式]

  连续分配管理：为一个用户进程分配一个连续的内存空间

  非连续分配管理：一个程序使用的内存分布在离散的内存中

  - 块式管理：将内存划分为几个固定大小的块，每个块只包含一个进程，很大一部分被浪费了
  - 页式管理：把主存分为大小相等且固定的页，页较小，通过页表对应逻辑地址和物理地址
  - 段式管理：分段是有逻辑意义的，一个段构成一个独立的地址空间，每个段的长度不同，且可以动态增长
  - 段页式：程序地址空间划分为多个拥有独立地址空间的段，每个段上的地址空间划分为大小相同的页。有分段的共享和保护，又有分页的虚拟内存

- 快表和多级页表

  为了加速虚拟地址到物理地址的转换速度，引入了快表

  可以理解为一种特殊的高速缓冲存储器（Cache）,存储页表的一部分或全部。用页表作地址转换，读取内存数据时CPU要访问两次主存，有了快表后只访问一次高速缓冲存储器，一次主存。

- 分页与分段的共同点与区别[透明性，维度，大小可变，出现的原因]

  - 透明性：分页对程序员是透明的，由操作系统决定每一页的大小。分段需要程序员显式划分。
  - 维度：分页是一维的，分段是二维的，逻辑地址由段号+段内地址构成
  - 大小可变：分页不可，分段可
  - 出现原因：分页用于实现虚拟内存，分段为了使程序和数据可被划分为逻辑上独立的地址空间且有助于共享和保护

- 逻辑（虚拟）地址和物理地址

  **逻辑地址指由程序产生的与段相关的偏移地址**

  **一个逻辑地址分成两个部分，一部分存储页面号，一部分存储偏移量。**

  **物理地址：真实的内存地址，出现在CPU外部地址总线上的寻址物理内存的地址信号**

- CPU寻址，虚拟地址空间？

  虚拟寻址，CPU将虚拟地址（逻辑地址）翻译成物理地址，才能访问真实的物理内存，逻辑地址到物理地址的转换由内存管理单元MMU完成

  **虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存**

  **为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页**

  **虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能**

  程序直接访问和操作的都是物理内存：

  - 用户程序可以访问任意内存，寻址内存的每个字节，容易破坏操作系统
  - 不方便管理，运行多个程序时，内存地址可能被其他程序覆盖

  使用逻辑地址的好处：

  - 使用相邻的虚拟地址来访问物理内存中不相邻的内存缓冲区
  - 程序可使用虚拟地址来访问大于物理内存的内存
  - 不同进程使用虚拟地址彼此隔离

- 页面置换算法

  程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间

  页面置换算法的主要目标是使页面置换频率最低

  - 最佳OPT：被换出的页面是未来最长时间不被访问的
  - 最近最久LRU：根据过去的情况预测未来，将最久未使用的页面置换
  - 最近未使用NRU：访问位R,修改位M，随机从类编号最小的非空类中挑选一个页面将它换出
  - 先进先出FIFO：选择换出的是最先进入的页面
  - ~~第二次机会算法：当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端~~
  - 时钟：时钟算法使用环形链表，用一个指针指向最老的页面

- 局部性原理

  - 虚拟内存的技术基础

    基于局部性原理，程序装入时，可以只装入一部分，将其他部分留在外存。程序执行时，所访问的信息不在内存时，由操作系统将需要的调入

  - 时间局部性

    程序中的某条指令一旦执行，不久之后该指令可能再次执行

    某条数据被访问后，不久以后该数据可能被再次访问

  - 空间局部性

    一旦程序访问了某个存储单元，不久之后，其附近的存储单元也将被访问。程序在一段时间内所访问的地址可能集中在一定的范围内。

- 虚拟内存的技术实现

  - 虚拟内存的实现建立在离散分配的内存管理方式上，三种实现
  - 请求分页存储管理：建立在分页管理基础上，增加了请求调页和页面置换。
  - 请求分段管理：
  - 请求段页管理：

## 4. 设计原则

- 单一职责原则

  **一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中**

  用于控制类的粒度大小

  就一个类而言，应仅有一个引起它变化的原因

- 开闭原则

  **软件实体应当对扩展开放，对修改关闭**

  软件实体应尽量在不修改原有代码的情况下进行扩展

  软件实体可以是一个软件模块，独立的类

- 里式替换原则

  **所有引用基类的地方必须能透明地使用其子类的对象**

  尽量使用基类类型来对对象定义

- 依赖倒置原则

  **高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象**

  针对接口编程，不要针对实现编程

  尽量引用层次高的抽象类

  针对抽象层编程，将具体类对象通过依赖注入的方式注入到其他对象

- 接口分离原则

  **客户端不应该依赖那些它不需要的接口**

  当一个接口太大时，需要分割为一些更小的接口

  每个接口承担一种相对独立的角色

- 合成复用原则

  **优先使用对象组合，而不是继承来达到复用**

  在一个新对象里通过关联关系使用已有的对象

  通过委派调用已有对象的方法达到复用

- 迪米特法则

  **最少知识原则：每一个软件单位对其他单位都只有最少的知识且局限于与本单位密切相关的软件单位**

  一个软件实体应尽可能少的与其他实体发生相互作用

  尽量减少对象之间的交互

  需要调用另一个对象的方法，可以通过第三者转发

## 5. 设计模式

#### 1. 概述

- 定义

  模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案

- 设计模式

  设计模式是特定环境下为了解决某一通用软件设计问题提供的一套定制的解决方案

- 分类

  - 创建型模式：创建对象
  - 结构型模式：处理类或对象的组合
  - 行为型模式：描述类或对象如何交互和分配职责

#### 2. 简单工厂模式

- **定义**

  定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实列通常有共同的父类

- 在简单工厂模式中用于创建实例的方法通常是静态方法，静态工厂方法

- 传入一个正确的参数就可获取所需的对象，无须知道创建细节

- java创建对象的方式

  - 使用new 关键字
  - 通过反射
  - 通过克隆
  - 通过工厂类

- **优点**

  - **实现了对象创建和使用的分离**
  - **客户端无须知道所创建的具体产品的类的类名**
  - 引入配置文件，不修改任何客户端代码更换和增加新的具体产品类

- **缺点**

  - **工厂类职责过重**
  - **系统扩展困难，添加**新产品要改工厂逻辑
  - 工厂角色无法形成基于继承的等级扩展

- **适用环境**

  - 工厂类负责创建的对象比较少
  - 客户端只知道传入工厂类的参数，不关心如何创建对象

#### 3. 工厂方法模式

- 定义

  **定义一个用于创建对象的接口，让子类决定将哪个类实例化。工厂方法模式让一个类的实例化延迟到其子类**

- 又称为工厂模式，工**厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象**

- 目的

  将产品类的实例化操作延迟到工厂类中完成

- 优点

  - 让工厂自主确定创建何种产品对象
  - 向客户隐藏了哪种具体产品类将被实例化
  - 加入新产品完全符合开闭原则

- 缺点

  - 类的个数成对增加，一定程度上增加了复杂度
  - 增加系统的抽象性和理解难度

- 适用环境

  - 客户端不知道它所需要的对象的类
  - 抽象工厂类通过其子类来指定创建哪个对象

#### 4. 单例模式

- 定义

  确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一的实例

- 懒汉模式

  ```java
  public class Singleton{
  	private static Singleton instance = null;
  	
  	private Singleton(){
  	}
  	
  	public static Singleton getInstance(){
  		if(instance == null){
  			instance = new Singleton();
  		}
  		return instance;
  	}
  	
  }
  ```

- 饿汉模式

  ```java
  public class Singleton{
  	private static final Singleton instance = new Singleton();
  	private Singleton(){
  	}
  	public static Singleton getInstance(){
  		return instance;
  	}
  }
  ```

- 一重锁

  ```java
  // 延迟加载
  public class Singleton{
  	private static Singleton instance = null;
      private Singleton(){
      }
      public synchronized static Singleton getInstance(){
      if(instance == null){
      	instance = new Singleton();
      }
      return instance;
      } 
  } 
  ```

- 双重检查锁

  ```java
  public class Singleton{
  	// 保证每次改变能被看见
  	private volatile static Single instance = null;
  	private Singleton(){
  	}
  	public static Singleton getInstance(){
  		// 为空才进行同步，减小开销
  		if(instance == null){
  			sychrnonized(Singleton.class){
  				if(instance == null){
  					instance = new Singleton();
  				}
  			}
  		}
  	}
  }
  ```

- 比较

  - 饿汉：线程安全，速度和反应时间优于懒汉模式。资源利用效率不及懒汉。
  - 懒汉：延迟加载，必须处理好多线程。需要双重检查锁机制，性能

- 优点

- 缺点

- 适用环境

  - 系统只需要一个实例对象
  - 只允许使用一个公共访问点

#### 5. 适配器模式

- 定义

  将一个类的接口转化为客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作

- 又叫包装器模式

- 类适配器与对象适配器

- 优点

  - 将目标类和适配者类解耦
  - 增加了类的透明性和复用性

- 缺点

- 适用环境

  - 需要使用一些现有的类，这些类的接口不符合系统需要
  - 创建一个可以重复使用的类，用于和其他类一起工作

#### 6. 迭代器模式

- 定义

  提供一种方法顺序访问一个集合对象中国各个元素，且不用暴露该对象的内部表示

- 又名游标模式

- 通过引入迭代器，客户端无须了解聚合对象的内部结构即可实现对聚合对象中成员的遍历，还可以根据需要方便地增加新的遍历方式

- 优点

- 缺点

- 使用场景

  - 访问一个聚合对象的内容而无需暴露它的内部表示
  - 为一个聚合对象提供多种遍历方式
  - 为遍历不同的聚合结构提供一个统一的接口

#### 6.组合模式

- 定义

  组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象

- 又称为“部分-整体”模式

- 将对象组织到树形结构，可用来描述整体与部分的关系

- 优点

- 缺点

- 适用场景

  - 具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们
  - 处理一个树形结构

#### 7. 装饰模式

- 定义

  动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰者模式提供了一种比使用子类更加灵活的替代方案

- 在不改变一个对象本身功能的基础上给对象增加额外的新行为

- 对客户透明的方式动态地给一个对象附加更多的责任

- 再不需要创建更多子类的情况下，让对象的功能得到扩展

- 优点

- 缺点

- 适用场景

  - 在不影响其他对象的情况下，以动态，透明的方式给单个对象添加职责
  - 当不能采用继承的方式对系统进行扩展或采用继承不利于系统扩展和维护时

#### 8. 外观模式

- 定义

  为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

- 又称为“门面模式”

- 迪米特法则的一种具体实现

- 通过引入一个新的外观角色来降低原有系统的复杂度

- 优点

- 缺点

- 适用场景

  - 要为访问一系列复杂的子系统提供一个简单入口
  - 客户端程序与多个子系统之间存在很大的依赖性
  - 层次化结构中，可使用外观模式定义系统中每一层的入口

#### 9. 代理模式

- 定义

  给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问

- 代理对象在客户端对象和目标对象之间起到中介的作用

- 远程代理：为一个位于不同的地址空间的对象提供一个本地的代理对象

  客户端可以访问在远程主机上的对象，将网络的细节隐藏起来，远程代理对象承担了大部分网络的通信工作

- 虚拟代理：若需要创建一个资源消耗较大的对象，先创建一个消耗较小的对象来表示，真实对象只在需要时被创建

  虚拟对象扮演真实对象的替身

- 缓冲代理

- Java提供了动态代理

- 优点

- 缺点

- 适用场景

  - 客户端需要访问远程主机中的对象时使用**远程代理**
  - 当需要一个消耗资源较少的对象来代表一个消耗资源较多的对象，降低系统开销可用**虚拟代理**
  - 为某个被频繁访问的操作结果提供一临时空间以供多个客户端共享访问时可以使用**缓冲代理**

#### 10. 观察者模式

- 定义

  定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并自动更新

- 又叫发布-订阅模式

- 事件源充当观察目标角色，事件监听器充当抽象观察者角色，事件处理对象充当具体观察者角色

- MVC架构中，模型层的数据发生改变时，视图层将自动改变其显示内容

- 优点

- 缺点

- 适用场景

  - 抽象模型的一方面依赖另一方面，封装起来独自改变和复用
  - 一个对象的改变将导致一个或多个其他对象发生改变
  - 在系统中创建一个触发链

#### 11.  状态模式

- 定义

  允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类

- 将一个对象的状态从该对象中分离出来，封装到专门的状态类中

- 用于解决系统中复杂对象的状态转换以及不同状态下行为的封装

- 优点

  - 封装了状态转换规则，可以对状态转换代码进行集中管理
  - 将所有与某个状态有关的行为放在一个类里面

- 缺点

  - 对开闭原则的支持并不好

- 适用场景

  - 对象的行为依赖于它的状态，状态的改变将导致行为的变化
  - 在代码中包含大量与对象状态有关的条件语句

#### 12. 策略模式

- 定义

  定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它的客户变化

- 又称政策（Policy）模式

- 每一个封装算法的类称之为策略类

- 策略模式提供了一种可插入式算法的实现

- 优点

  - 管理相关的算法族的办法
  - 避免多重条件选择语句
  - 对开闭原则的完美支持

- 缺点

  - 客户端必须知道所有的策略类
  - 无法同时在客户端使用多个策略类

- 适用场景

  - 一个系统需要动态地在算法中选择一种
  - 避免使用难以维护的多重条件选择语句

#### 13. 模板方法模式

- 定义

  定义一个操作中的算法框架，而将一些步骤延迟到子类中。模板方法模式使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤

- 是一种基于继承的代码复用技术

- 将一些复杂流程的实现步骤封装在一系列基本方法中

- 优点

  - 在子类实现详细的处理算法时并不会改变算法中步骤的执行次序
  - 将公共行为放在父类中
  - 可实现一种反向控制结构，子类覆盖父类的钩子方法决定某一特定步骤是否需要执行

- 缺点

  - 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，也会导致类的个数的增加

- 适用场景

  - 一次性实现一个算法中不变的部分，并将可变的行为留给子类来实现
  - 公共行为提取，避免代码重复
  - 反向控制

## 6. MySQL

#### 1. 什么是MySQL

MySQL是一种关系型数据库，在Java企业级开发中很常用，MySQL是开源免费的，且方便扩展。默认端口3306

#### 2. 存储引擎

MyISAM和InnoDB的区别

MyISAM是MySQL 5.5之前的默认数据库引擎。设计简单，数据以紧密格式存储。提供了如压缩表，空间数据索引对于只读数据，或者表比较小，可以容忍修复操作也能用。崩溃后无法安全恢复，不支持事务和行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁。写入时则对表加排他锁。可以手工或者自动执行检查和修复操作

InnoDB是MySQL5.5之后的默认事务型存储引擎。实现了四个标准的隔离级别。默认是可重复读。在可重复读隔离级别下，通过多版本并发控制MVCC + Next Key Locking 防止幻影读。主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘。支持真正的在线热备份

- 事务：InnoDB是事务型，可用Commit和Rollback，有崩溃修复能力的事务安全型表。MyISAM强调性能，每次查询有原子性，执行速度比InnoDB快
- 并发：MyISAM只支持表级锁，而InnoDB还支持行级锁
- 外键：InnoDB支持，MyISAM不支持
- 备份：InnoDB支持在线热备份
- MVCC：仅InnoDB支持。应对高并发事务，MVCC比单纯加锁更高效

#### 3. 字符集以及校对规则

- 字符集指的是一种从二进制编码到某类字符符号的映射：ascii,gbk,utf8
- 校对规则是某种字符集下的排序规则:_ci（大小写不敏感），__cs（大小写敏感）或/_bin（二元结束）
- MySQL采用类似继承的方式指定字符集的默认值，每个数据库以及每张表都有自己的默认值

#### 4. 索引

- B树索引与B+树索引
  - B树结构
  
    一个m阶的B树，任意非叶子节点最多m个子节点，除根节点外的非叶子节点最少m/2，而每个节点至少存放m/2-1个关键字，至多存m-1个关键字
  
  - B+树结构（用于数据库和操作系统）
  
    **B+树m个关键字，m个叶子节点，关键字只是用来存储索引**
  
    （B树也有m个子节点，但只有m-1个关键字）
  
    **B+树的数据都存储在叶子节点，内部节点只有索引信息**(B树的数据存储在每一个节点中)
  
    B树找到具体数值后就结束，而**B+树则通过索引找到到叶子节点中的数据才结束**
  
  - B+树更适合做索引
  
    **B+树的磁盘读写代价更低**：内部并没有指向关键字具体信息的指针，内部节点相对B树更小。盘块容纳的关键字数量多，树高低，减少IO。
  
    **B+树的查询效率更加稳定：**任何关键字查找必须走一条从根节点到叶子节点的路
  
- 为什么用B+树

  - B+树能显著减少IO次数，提高效率
  - B+树查询效率更稳定，数据都放在叶子节点
  - **B+树能提高范围查询的效率**，叶子节点指向下一个叶子节点

- MySQL索引使用的数据结构主要有B+Tree和哈希索引。

- Hash索引底层的数据结构就是哈希表，**调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据**。在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快，其余选BTree。

  **仅能满足“=”，"in","<=>"查询，不能范围查询，不能用来避免数据的排序，不能用于部分索引**，Hash碰撞

- 聚簇索引：索引项的顺序与表中记录的物理顺序一致。非聚簇则不一致

- MyISAM：B+Tree叶子节点的data节点

- InnoDB

#### 5. 查询缓存的使用

- 开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果
- 缓存建立后，MySQL的查询缓存系统会追踪查询中涉及的每张表，表变化则缓存数据失效
- 缓存能提升数据库的查询性能，但缓存同时也带来了额外的开销。每次查询后都要做一次缓存操作，失效后还要销毁

#### 6. 什么是事务

事务是逻辑上的一组操作，要么全执行，要么都不执行

- A

- C

- I（隔离性）：一个事务在所做的修改最终提交以前，对其他事务是不可见的

- D：一旦事务提交，其所做的修改会永远保存在数据库中。发生崩溃，事务执行的结果也不能丢失

  **系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性**。与回滚日志记录数据的逻辑修改不同，**重做日志记录的是数据页的物理修改。**

#### 7. 并发事务带来哪些问题

- 脏读：读到其他事务未提交的数据
- 丢失修改：一个事务的更新操作会被另一个事务的更新操作替换
- 不可重复读：一个事务多次读取某数据，另一个事务也做了修改，两次读取的数据可能不一致
- 幻读：读取某个范围，另一个在这个范围内插入数据

#### 8. 事务隔离级别有哪些?MySQL的默认隔离级别

- 未提交读：事务中的修改，即使没提交，对其他事务也是可见的

- 提交读：一个事务只能读取已提交的事务所做的修改

- 可重复读：对同一字段的多次读取结果都是一致的，除非被本身修改

- 可串行化：强制事务串行执行，多个事务互不干扰，不会出现并发一致性问题

  InnoDB存储引擎在可重复读事务隔离级别下使用Next-Key Lock锁算法，可避免幻读产生

#### 9. 锁机制与InnoDB锁算法

- MyISAM：采用表级锁
- InnoDB：支持行级锁和表级锁，默认行级锁

表级锁和行级锁比较

- 表级锁：MySQL中粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗少。触发锁冲突的概率最高，并发度最低
- 行级锁：MySQL中粒度最小的一种锁，只针对当前操作的行加锁。加锁粒度最小，数据库操作冲突的概率最低，并发度最高。但加锁的开销大，加锁慢，可能出现死锁

InnoDB存储引擎的锁的算法

- Record Locks：锁定一个记录上的索引，而不是记录本身，若表没有设置索引，InnoDB会自动在主键上创建隐藏的聚簇索引
- Gap Locks: 锁定索引之间的间隙，但不包括索引本身
- Next-Key Locks: 是Record Locks和Gap Locks的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙

#### 10. 大表优化

- 限定数据的范围

- 读/写分离：主服务器处理写操作以及实时性要求比较高的读操作，从服务器处理读操作。缓解了锁的争用，从服务器可使用MyISAM

- 水平分区：将**同一张表中的记录拆分到多个结构相同的表中，可以将数据分布到集群的不同节点上，缓解单个数据库的压力但分片事务难以解决，跨节点Join性能较差**
  
  Sharding策略：**哈希取模，范围（ID或时间），映射表**
  
  - 客户端代理：分片逻辑在应用端，封装在jar包中，通过封装或修改JDBC层来实现
  - 中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中
  - ~~问题解决：~~
    - ~~事务：分布式事务~~
    - ~~连接：单表，然后在用户程序拼接~~
    - ~~ID唯一性：全局唯一ID,分片ID范围，分布式ID生成器~~
  
- 垂直分区：将一张表按列切分为多个表，通常按照列的关系密集程度进行切分，也可将经常使用的列和不经常使用的列切分到不同的表中
  - 优点：使得列数据变小，简化表结构，易于维护
  - 缺点：主键出现冗余，让事务变得复杂

#### 11. 池化，数据库连接池

池化

- **池化设计会预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销**
- 池子的初始值，池子的活跃值，池子的最大值等等
- java线程池，jdbc连接池，redis连接池

数据库连接池

- 数据库连接本质是一个Socket连接，数据库服务端还要维护一些缓存和用户权限信息之类的信息。可以把数据库连接池看做维护的数据库连接的缓存，以便将来需要对数据库请求时可以重用这些连接
- 在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。若使用了所有连接，则会建立一个新的连接放在池中

#### 12. SQL语句在MySQL中如何执行

- **连接器**首先服务器端的连接器对客户端进行身份认证和权限检查
- **查询缓存**执行查询语句是会先查询缓存，在MySQL8.0后移除
- **分析器**没有命中缓存，SQL语句就会经过分析器，词法分析和语法分析
- **优化器**：用最优的执行方案去执行，如何选择索引等
- **执行器**：执行语句，返回结果

#### 13. SQL优化

#### 14. SQL执行慢的原因

- 大多数情况下正常，偶尔慢
  - 数据库在刷新脏页，例如redo log写满了
  - 执行的时候，遇到了锁
- 一直很慢
  - 没有用上索引：例如该字段没有索引，对该字段进行运算导致索引失效
  - 数据库选错了索引

#### 15. 索引的优缺点

优点

- 加快数据库检索的速度
- 创建唯一性索引，保证数据库表中每一行数据的唯一性
- 加速数据库表的连接

缺点

- 创建和维护索引耗费时间
- 索引需要占用物理空间
- 对数据库表中的数据进行增加，删除，修改时，索引也需要维护

失效

- 条件中有or，即使条件带索引页不会使用
- 多列查询，不是使用的第一部分不会
- like以%开头

适用场景

- 经常出现在order by ,group by ,distinct后的字段
- 经常用在查询
- 经常用在表连接

#### 16. 索引是怎么优化查询的

- 


#### 17. 数据库的死锁

#### 18. explain

- 基本概念：需要知道SQL的执行计划，如全表扫描，索引扫描。通过explain完成。explain是查看优化器如何决定执行查询的主要方法
- 详解

#### 19. MVCC

多版本并发控制是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别

**写操作更新最新的版本快照，而读操作去读旧版本快照。事务的修改操作会为数据行新增一个版本快照**

MVCC维护了一个ReadView结构，主要包含当前系统未提交的事务列表TRX_IDs，还有该列表的最小值TRX_ID_MIN和TRX_ID_MAX。TRX_ID<TRX_ID_MIN可以读

快照读：MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作

当前读：MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。

#### 20. Redo日志和Undo日志以及binlog

- binlog

  数据库主从同步通过同步binlog实现，binlog是没有MySQL server维护的一种二进制日志，**主要用来记录对MySQL数据更新或潜在发生更新的SQL语句，并以“事务”的形式保存在磁盘中**

  复制：Master端开启binlog，传给slaves来达到一致

  数据恢复：通过mysqlbin工具恢复

  增量备份

- undo log

  与redo log一样都不是数据库层面上的日志，而是InnoDB引擎存储的日志

  保证事务的原子性和MVCC

  **提供回滚和多版本并发控制下的读（MVCC）**

  **如果因为某些原因导致事务失败了，可以借助该undo回滚**

  **undo和redo记录的物理日志不一样，是逻辑日志，当delete一条记录时，undo log中会记录一条对应的insert记录**

  MVCC:当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行数据以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读

- redo log

  **重做日志，用来保持事务的持久性**。InnoDB记录了对数据文件的物理修改，并保证总是日志先行，在持久化数据文件之前，保证之前的redo日志已经写到磁盘。

  重做日志记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来

  在一条语句进行执行的时候，InnoDB 引擎会把新记录写到 redo log 日志中，然后更新内存，更新完成后就算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将 redo log 中的内容更新到磁盘中。

## 7. Redis

#### 1. Redis介绍

- 使用一个使用C语言开发的NoSQL内存键值对数据库，可以存储键和五种不同类型的值之间的映射
- 键的类型只能为字符串，值的类型为字符串，列表，集合，散列表，有序集合

#### 2. 分布式缓存

- Memcached与Redis
- 共同点
  - 都基于内存的数据库
  - 都有过期策略
  - 性能都很高
- 区别
  - Redis支持5种数据类型，Memcached只支持字符串类型
  - Redis支持RDB快照和AOF日志两种持久化策略，Memcached不支持持久化
  - Redis在服务器内存用完后，可以将不用的数据放磁盘上。Memcached在服务器内存用完后直接报异常
  - Redis Cluster支持分布式，Memcached 只能通过在客户端使用一致性hash来实现分布式
  - Memcached是多线程，非阻塞IO复用的网络模型；Redis 使用单线程多路IO复用模型（Redis 6引入了多线程IO）
  - 惰性删除，Redis使用惰性删除与定期删除

#### 3. Redis缓存处理流程

#### 4. 为什么用Redis/为什么要用缓存

- 提升用户体验以及应对更多的用户
- 用户访问的数据属于高频率且不会经常改变的话，可以放在缓存中。下一次访问时可以直接从缓存中获取。缓存放在内存中，速度很快
- 把数据库中的部分数据转移到缓存中，用户部分请求不会经过数据库。直接操作缓存能够承受的数据库请求远远大于直接访问数据库

#### 5. Redis常见的数据结构以及使用场景

- String
  - 命令
  - 使用场景：计数器，一般用在需要计数的场景，如用户访问次数，热点文章的点赞转发

- list：易于数据元素的插入和删除，且可灵活调整链表长度，双向链表
  - 命令
  - 消息队列
- hash :类似于JDK 1.8前的HashMap适合存储对象
  - 命令
  - 应用场景：对象数据的存储
- set:无序集合，不能重复
  - 命令
  - 应用场景：需要存放的数据不能重复或者计算交集，并集
- sorted set：增加了权重参数score 集合中的元素按score有序排列
  - 命令
  - 应用场景：根据某个权重排序

#### 6. Redis单线程模型详解

- Redis基于Reactor模式设计开发了自己的一套高效的事件处理模型
- 事件处理模型是文件事件处理器
  - 多个socket
  - IO多路复用程序
  - 文件事件分派器
  - 事件处理器
- 通过I/O多路复用来监听客户端的大量连接
- I/O多路复用技术让Redis不需要额外创建多余的线程来监听客户端大量的连接，降低了资源的消耗

#### 7. redis为什么不用多线程

- Redis 6 之前主要是单线程处理
- 单线程编程容易且易维护
- Redis的性能瓶颈不在CPU,在内存和网络，多线程提升不太大
- 多线程存在死锁，上下文切换，可能影响性能

#### 8. redis为什么引入了多线程

- 为了提高网络IO读写性能
- redis的多线程也只是在网络数据的读写上使用，执行命令仍是单线程顺序执行

#### 9. redis给数据设置过期时间

- 内存有限
- 确保内存中的数据是经常访问的

#### 10. 如何判断数据是否过期

- 通过一个过期字典（hash）来保存过期时间，过期字典的键指向了redis数据库中的某个key，值是一个long long 类型整数key所指向的数据库键的过期时间

#### 11. 过期删除策略

- 惰性删除：
  - 只有在取出key时才对数据进行过期检查，对CPU友好，可能造成太多过期key没被删
- 定期删除
  - 每隔一段时间抽取一批key执行删除过期操作
- 定时删除
  - 设置键值过期时间的同时创建定时器，让定时器在过期时间到来时对键值进行删除

#### 12. 淘汰机制

- volatile-lru :已设置过期时间的数据集删除

- volatile-ttl: 从设置过期时间的数据中心挑选要过期的数据

- volatile-random: 从已设置过期时间的数据中任取

- allkeys-lru：所有数据中移除最近最少使用的key

- no-evicition: 不驱逐数据

  4.0 以后挑选最不经常使用的

#### 13. Redis持久化

- RDB[默认]

  **创建快照来获得存储在内存里面的数据在某个时间点的副本**

  可以对快照进行备份，可以复制到其他服务器

- AOF

  append-only file,AOF持久化的实时性更好

  **开启AOF持久化后，每执行一条更改redis中数据的命令，redis就会将该命令写入硬盘中的AOF文件**。

  可以每次修改都写入，可以每秒同步一次，也可以让操作系统决定

#### 14. Redis事务

- 可以通过MULTI，EXEC，DISCARD，WATCH命令来实现事务
- 事务ACID
- Redis不支持回滚，不满足原子性和持久性
- 多个命令打包，按顺序执行且中途不会被打断

#### 15. 缓存穿透

- 对某一个不存在的数据进行请求，该请求会穿透缓存到达数据库
- 解决方案
  - 缓存无效的key，尽量将过期时间设置的短一点
  - 布隆过滤器
    - 通过这个过滤器非常方便的判断一个给定的数据是否存在于海量的数据中
    - 把所有可能存在的请求的值都放在布隆过滤器中，用户请求过来时，先判断请求的值是否在布隆过滤器中
    - 底层原理：https://www.cxyxiaowu.com/1328.html

#### 16. 缓存雪崩

- 由于数据没有被加载到缓存中，或者**缓存在同一时间大量失效**，又或者缓存服务器宕机**导致大量的请求都到达数据库**
- 解决方案
  - 使用Redis集群，避免单机出现问题导致缓存服务不能使用
  - 限流，避免同时处理大量请求
- 针对热点缓存
  - 设置不同的失效时间
  - 永不失效

#### 17. 如何保证缓存和数据库数据一致

- 旁路缓存模式

  更新数据库，然后直接删除cache

  如果更新数据库成功，而删除缓存失败

  - 将缓存失效时间变短：先操作后缓存的数据库场景不适用
  - 增加缓存更新重试机制：缓存服务不可用导致删除失败可以隔一段时间后重试

- 数据更新的同时更新缓存

#### 18. 缓存无底洞

- 为了满足业务要求增加了大量缓存节点，但性能没有好转
- 原因：缓存系统采用hash函数将key映射到对应的缓存节点，缓存节点增加键值分布到更多的节点，涉及多次网络操作
- 解决方案
  - 优化批量数据操作命令
  - 减少网络通信次数

#### 19. Redis集群

1.twemproxy
2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它**支持在节点数量改变情况下，旧节点数据可恢复到新hash节点。**
3.Redis cluster3.0自带的集，特点在于他的**分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。**

hash槽：

#### 20. Redis高可用

采用主从架构，对主节点的数据进行多个备份，如果主节点挂掉，可以立刻切换状态最好的从节点为主节点，并从其他从节点向新主节点同步数据。

全量复制：从节点因为故障恢复或者添加从节点时出现的初始化阶段的数据复制，将主节点的数据全部同步到从节点来完成

增量复制：是主从结点正常工作之后的每个时刻进行的数据复制方式，使用定长环形数组(队列)来实现，~~如果buffer满了那么新数据将覆盖老数据，因此从结点在复制数据的同时向主节点反馈自己的偏移量，从而确保数据不缺失~~

#### 21. 哨兵和复制

哨兵Sentainel：可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能，

复制Replication则是负责让一个Redis服务器可以配备多个备份的服务器

#### 22. 读写分离

通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。

读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于写密集类型的应用，读写分离架构并不适合。

Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。

当Redis多台机器分布在不同的网络中，如果出现网络故障，那么数据一致性和服务可用性无法兼顾，Redis系统对此必须做出选择，事实上Redis选择了可用性，或者说Redis选择了另外一种最终一致性

#### 23. Redis底层数据结构

- **Redis常用的5种数据结构如何实现的**

  - **String ：SDS简单动态字符串**
  - **List：ziplist压缩列表和linkedlist双端链表**
  - **Hash：zipliast压缩列表和hashtable哈希表**
  - **Set：intset整数集合和hashtable哈希表**
  - **Zset：skiplist跳跃链表和ziplist压缩列表**

- ziplist压缩列表

  作为Zset,set,list三种数据类型的底层实现，压缩是一种**为了节约内存而开发且经过特殊编码之后的连续内存块顺序型**数据结构

- Redis字典（hash）如何实现

  基于hashtable和ziplist实现

  **hashtable的实现如下**：

  **dictht哈希表结构 -> dictEntry哈希节点结构 -> dictType+rehashidx**

  dictEntry哈希表节点，也就是我们存储数据地方，其保护的成员有：key,v,next指针

  dictht哈希表包括的成员有table、size、used、sizemask。

- Redis的rehash

  redis使用MurmurHash算法计算哈希值

  哈希表保存的键值对数量是**动态变化**的，为了让哈希表的负载因子维持在一个合理的范围之内，就需要对哈希表进行扩缩容

  rehash基本步骤：分配空间 -> 逐个迁移 ->交换哈希表

  **找到大于等于ht[0]*2的2的N次方->重新计算hash迁移到后台ht[1]->释放ht[0],将ht[1]设置为ht[0]**

  采用渐渐式的rehash：并非一次性完成的，分多次，渐进式完成

  一次性完成可能会导致服务器在一段时间内停止服务

- 跳跃链表

  1.由很多层结构组成

  2.每一层都是一个有序的链表

  3.最底层的链表包含所有元素

  4.如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。

  5.每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。

  

  跳跃表按score从小到大保存所有集合元素。字典保存着从member到score的映射。

  跳表是一个概率型的数据结构，元素的插入层数是随机指定的。

  在元素小于128并且元素长度小于64字节时才会选择压缩列表实现，一般使用skiplist跳表实现

#### 24. Redis分布式锁

在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需**要同步的进程可能位于不同的节点上，那么就需要使用分布式锁**。互斥量为0，表示有其他进程在使用锁互斥量为1，未锁定

- **SETNX**

  set if not exist **使用SETNX指令插入一个键值对时，如果key已经存在，那么会返回False，否则插入成功并返回True。**

  与数据库的唯一索引类似，可以设置过期时间

- **RedLock**

  **使用了多个Redis实例来实现分布式锁，保证在发生单点故障时仍然可用**

  - 尝试从N个相互独立的Redis实例获取锁
  - 计算锁消耗时间，小于锁的过期时间且从大多数实例上获取了锁才认为成功
  - 获取失败则每个实例释放锁

#### 25. CAP

分布式系统不可能同时满足一致性，可用性，分区容忍性，最多满足其中两项

- 一致性 C

  **多个数据副本是否能保持一致性的特性**，在一致性的条件下，系统在执行数据更新之后能从一个一致性状态转移到另一个一致性状态

- 可用性 A

  **在面对各种异常时可以提供正常服务的能力**，可以用系统可用时间占总时间的比值来衡量。

  在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作总是能在有限时间内返回结果

- 分区容忍性 P

  网络分区指分布式系统中的节点被划分为多个区域，每个区域内可以通信，但区域之间无法通信

  在分区容忍性条件下，**分布式系统在遇到任何网络分区故障时，仍然需要对外提供一致性和可用性服务，除非整个网络发生了故障**

- 权衡

  - 分布式系统中，**分区容忍性必不可少，因为总是假设网络是不可靠的**。因此，CAP理论实际上是要在可用性和一致性之间权衡
  - 一致性（CP），不能访问未同步完成的节点，失去了部分可用性
  - 可用性（AP），允许读取所有节点的数据，但数据可能不一致

- 最终一致性

  **最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态**

## **8. Spring**

### 1. 什么是Spring框架

spring是一种轻量级开发框架，旨在提高开发人员的效率以及系统的可维护性

Beans组件和Context组件是实现IOC和依赖注入的基础。AOP用来实现面向切面编程

### 2. 列举一些重要的Spring模块

- Spring Core：Spring其他所有功能都要依赖于该类库，主要提供IOC依赖注入功能
- Spring Aspects：该模块为AspectJ的集成提供支持
- Spring AOP：提供了面向切面的编程实现
- Spring JDBC：Java数据库连接
- Spring JMS：Java消息服务
- Spring ORM：用于支持Hibenate等ORM工具
- Spring Web：为创建Web应用程序提供支持
- Spring Test：提供了JUnit和TestNG测试的支持

### 3. @RestController 与 @Controller

- Controller返回一个界面

  单独使用@controller不加@responsebody一般用在要返回一个视图的情况。属于比较传统的Spring MVC，对应前后端不分离的情况

- @RestController返回JSON或XML形式数据

  RestController只返回对象，对象数据直接以JSON或XML形式写入HTTP响应中，RESTful Web服务

- ResponseBody注解将Controller方法返回的对象通过适当的转换器转换为固定的格式后写入到HTTP响应对象的Body中

### 4. Spring IOC 和AOP

- IOC

  控制反转是一种设计思想，将原本在程序中手动创建对象的控制权交由Spring框架管理。IOC容器是Spring用来实现IOC的载体，IOC容器实际上就是个Map(Key,value)，Map中存放的是各种对象。

  **将对象之间的相互依赖关系交给IOC来管理，并由IOC容器来完成对象的注入。IoC容器就像是一个工厂，当我们需要创建一个对象时，只需配置好文件/注解即可，完全不用考虑对象是如何被创建出来的**

  IoC初始化过程：XML->读取->Resource->解析->Beandefinition->注册->Beanfactory

- AOP

  AOP（面向切面编程）能将那些与业务无关，却为业务模块所共同调用的逻辑或责任（事务处理，日志管理，权限控制）封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可拓展性和可维护性。

  Spring AOP基于动态代理，要代理的对象实现了某个接口，那么AOP会使用JDK Proxy去创建代理对象，而对于没有实现接口的对象会用CgLib。这时会用Cglib生成一个被代理对象的子类。

- Spring AOP和Aspect AOP区别

  Spring AOP是运行时增强，而AspectJ是编译时增强。Spring基于代理而Aspect基于字节码操作

  Spring AOP集成了AspectJ, 而AspectJ是Java生态中最完整的AOP框架

### 5. Spring bean

- bean的作用域

  - singleton：唯一bean实例，Spring中bean默认都是单例的
  - prototype：每次请求都会创建一个新的bean实例
  - request：每次HTTP请求都会产生一个新的bean，仅在HTTP Request内有效
  - Session：每次HTTP请求都会产生一个新的bean，仅在HTTP session内有效
  - global-session：全局Session作用域，仅仅在基于portlet的web应用中才有意义。Spring5中已没有

- 单例bean的线程安全问题

  存在线程安全问题，主要是因为在多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题

  - 在bean中尽量避免定义可变的成员变量
  - 在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在threadLocal中

- @component 和 @ bean的区别

  - 作用对象不同：@component作用于类，而@bean作用于方法

  - @component通常通过类路径扫描自动侦测以及自动装配到Spring容器中

    可以使用@componentScan注解来定义要扫描的路径，从中找出标识了需要装配的类

    @Bean注解通常是我们在标有该注解的方法中定义产生这个bean，@bean告诉Spring是这个类的示例

  - @bean注解比@conponent注解的自定义性更强，很多地方只能@bean注解来注册bean

- 将类声明为Spring的bean的注解

  - @component：通用的注解，可标记任意类的Spring组件
  - @reposity：对应持久层，即Dao层，主要用于数据库相关操作
  - @service：对应业务逻辑层，需要用到Dao
  - @controller：控制层，接收用户请求并调用Service层返回数据给前端页面

- bean的生命周期

  - **Bean容器找到配置文件中Spring Bean的定义**
  - Bean容器利用Java Reflection API创建一个Bean的实例
  - 若涉及到一些属性值利用set()方法设置属性值
  - 若Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字
  - 若Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例
  - 与上面的类似，如果实现了其他*.Aware接口，就调用相应的方法
  - 如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法
  - 如果Bean实现了InnitializingBean接口，执行afterPropertiesSet()方法。
  - 如果Bean在配置文件中的定义包含init-method属性，执行指定的方法
  - 如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法
  - 当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。
  - 当要销毁Bean的时候，如果Bean在配置文件中的定义包含destory-method属性，执行指定的方法

### 6. SpringMVC

- ~~Model1：几乎整个Web都用JSP，少量的JavaBean处理数据库连接~~

  ~~JSP即是控制层又是表现层~~

  - ~~控制逻辑与表现逻辑混杂在一起，代码重用率低~~
  - ~~前后端相互依赖，难以测试且开发效率低~~

- ~~Model2：Java Bean(Model) + JSP（View）+Servlet(Controller)~~

  ~~Model系统涉及的数据，View展示模型中的数据，Controller处理用户请求~~

- SpringMVC

  是一个基于MVC架构的用来简化Web应用程序开发的应用开发框架，是Spring的一个模块，无需中间整合层来整合，它属于表现层的框架。在web模型中，通过把Model，View，Controller分离，把较为复杂的Web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合

- 执行流程（工作原理）

  1. 用户发送请求至前端控制器DispatcherServlet
  2. DispatcherServlet收到请求调用HandlerMapping处理器映射器
  3. 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器一并返回给DispatcherServlet
  4. DispatcherServlet通过HandlerAdapter处理器适配器调用处理器
  5. 执行处理器（Controller，也叫后端控制器）
  6. Controller执行完后返回ModelAndView
  7. HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet
  8. DispatcherServlet将ModelAndView传给ViewReslover
  9. ViewReslover解析后返回具体View
  10. DispatcherServlet对View进行渲染视图
  11. DispatcherServlet响应用户

- SpringMVC加载流程

  1. Servlet加载（监听器之后即执行）的Servlet的init()
  2. 加载配置文件
  3. 从ServletContext拿到spring初始化SpringMVC相关对象
  4. 放入ServletContext

- Servlet

  是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的**中间层**。

### 7. Spring框架中的设计模式

- 简单工厂模式

  Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否在传入参数后创建还是传入参数前创建视情况而定

- 单例模式

  保证一个类仅有一个实例，并提供一个访问它的全局访问点

  spring中的单例模式提供了全局访问点BeanFactory。

- 适配器模式

  Spring的AOP中国使用的Advice来增强代理类的功能。

- 代理模式

- 观察者模式

  定义对象之间一对多的依赖关系，但一个对象发生变化时，所有哦依赖于它的对象都得到通知并自动更新

- 模板模式

  定义一个操作中算法的骨架，而将一些步骤延迟到子类中。

  使用JDBC Templates时用到了

### 8. Spring事务

### 9. JPA

## 9. RabbitMQ

#### 1. 为什么使用MQ

异步，解耦，削峰填谷

- 异步：**把多个消息放到消息队列等待消费者来取，**消费者可并行处理
- 解耦：**系统A不直接与其他系统交互而是通过MQ进行通信**
- 削峰：**减少高峰时期对服务器压力，把高峰期处理不了的数据放在消息队列**

#### 2. MQ的缺点

- 增加了架构的复杂性，降低了可用性。
- 原本没有mq的情况，我们只需要关注各个系统是否正常，现在多加了一个MQ，由于彼此都是采取MQ进行消息的消费，所以一旦MQ宕机了，整个系统就不能用了。
- 还有就是系统的复杂度，加了一个MQ，如何保证消息的重复消费，怎么处理消息丢失，还有就是消息传递的顺序性等等
- 还有一致性问题。默认都执行成功了，但最后却不一定

#### 3. Kafka,ActiveMQ, RabbitMQ,RocketMQ都有什么特点

- 单机吞吐量

  ActiveMQ万级, RabbitMQ万级,RocketMQ十万级，Kafka十万级

- 时效性

  ActiveMQ: ms, RbbitMQ 微秒级，延迟最低，ms，ms

- 可用性

  高（主从架构），高（主从架构），非常高（分布式架构），非常高（分布式）

- 持久化

  `ActiveMQ` 和`RabbitMQ` 都支持。持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制

- 可靠性

  ActiveMQ较低概率丢失数据，RocketMQ,KafKa可配置降到0

  RbbitMQ低延迟，高并发(基于erlang语言开发)，性能好且支持持久化，更成熟

  AvctiveMQ维护较少

  中小型：RabbitMQ 大型：RocketMQ

  Kafka主要用于大数据领域的实时计算以及日志采集

#### 4. 如何保证高可用？

RabbitMQ基于主从架构保证高可用

- 单机模式：用作演示或测试的，生产环境下不用
- 普通集群模式：多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。**创建的queue只会放在一个RabbitMQ实例上，但每个实例都会同步queue的元数据（配置信息）**.消费时连接从queue所在实例拉取。**提高吞吐量**
- **镜像集群模式**：每个RabbitMQ节点都有这个queue的一个完整镜像，包含queue的全部数据。每次写的时候也会把消息同步到多个实例的queue上。镜像集群模式的策略在指定的时候可要求数据同步到所有节点，也可要求同步到指定数量的节点 **高可用但开销大**

#### 5. 如何保证消息不被重复消费

- 幂等性：一个数据或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。
- 基于数据库的唯一键
- **生产者发送消息的时候带上一个全局唯一的id**
- 拿数据写库时，检查主键，如果有数据则不插入进行更新

#### 6. 如何保证消息不丢失

- 生产者丢失：生产者写消息的过程中，消息没到rabbitMQ就在网络中丢失了。或者到了但没有保存下来

  解决方案：

  1. 开启RabbitMQ事务（同步，生产者发送消息会同步阻塞卡住等待你是成功还是失败）
  2. **开启confirm模式**（异步，rabbitmq回调接口告诉成功与否）

- MQ中丢失：接收到消息后暂存到主机内存，没来得及消费，MQ挂了

  解决方案：**开启RabbitMQ持久化**（写到磁盘）

- 消费端丢失：消费者拿到了消息，但是没来得及处理自己就挂了，MQ以为处理完了

  解决方案：**消费者开启了自动ACK**，消费一条消息还没处理完就自动ACK,通知mq已消费。**关闭自动ACK**，处理完后在发送ACK

#### 7. 如何保证消息队列的顺序性

需要保证顺序的数据放到同一个queue里，每个queue一个consumer。

#### 8. 如何解决消息队列的延时以及过期失效问题？队列满了后如何处理，几百万消息持续积压，怎么解决

消息积压：临时扩容

- **先修复 consumer 的问题**，确保其恢复消费速度，然后将现有的 consumer 都停掉

- **新建一个topic,partition是原来的 10 倍**，临时建立好原先 10 倍的 queue 数量

- **然后写一个临时的分发数据的 consumer 程序**，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue

- **接着临时征用 10 倍的机器来部署 consumer,**每一批 consumer 消费一个临时 queue 的数据

- 这种做法相当 于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常 10 倍速度

- 等快速消费完积压数据之后，恢复原先部署架构 ，重新用原先的 consumer机器消费消息

  修复 -> 10倍的queue -> 分发的consumer -> 10倍的consumer -> 恢复

消息失效：RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉。**批量重导**

消息队列满了：临时写程序，接入数据来消费，**消费一个丢弃一个，都不要了**，快速消费掉所有的消息，然后到了空闲时刻补数据

#### ~~9. 如何设计消息队列中间件~~

- ~~可伸缩性：设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -> topic -> partition，每个 partition 放一个机器，就存一部分数据。~~
- ~~持久性：mq数据落磁盘，避免进程挂了数据丢了，顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这个就是 kafka的思路~~
- ~~高可用性：多副本 -> leader & follower -> broker 挂了重新选举 leader 即可对外服务~~
- ~~数据0~~

### 10. RabbitMQ的底层原理

#### 1. 底层组件

- **Server：Broker消息队列服务器实体**
- **Channel：消息通道，读写都在Channel中进行，每个channel代表一个会话任务**
- **Message：由properties和body组成**
- **Virtual host：虚拟主机，用于消息隔离，一个broker里开设多个vhost**
- **Exchange：路由和过滤，消息交换机，指定消息按什么规则，路由到哪个队列**
- **Binding：把Exahcange和Queue按照路由规则进行绑定**
- **Routing key：路由规则，Exchange根据这个关键字进行消息投递**
- **Queue：消息队列载体，每个消息都会被投入到一个或多个队列，队列又分为临时队列，持久化队列，排他队列**
- **Producer：消息生产者，投递消息**
- **Consumer：消息消费者，接收消息**

#### 2. AMQP协议

- RabbitMQ是开源消息队列系统，AMQP（高级消息队列协议）的标准实现，由以高性能，健壮，可伸缩性的Erlang语言开发。
- RabbitMQ的进程模型是一种高性能的非阻塞io线程模型
  - tcp_acceptor进程接收客户端连接，创建rabbit_reader,rabbit_writer,rabbit_channel进程
  - rabbit_reader接收客户端连接，解析AMQP帧，rabbit_writer向客户端返回数据
  - rabbit_channel解析AMQP方法，对消息进行路由，然后发给相应队列进程
  - rabbit_amqqueue_process是队列进程，在RabbitMQ启动或创建队列时创建
  - rabbit_msg_store是负责消息持久化的进程
  - 整个系统中，存在一个tcp_accepter进程，一个rabbit_msg_store进程，一个队列对应一个rabbit_amqqueue_process进程
- AMQP帧
  - 帧类型
  - 信号编号
  - 帧大小
  - 帧有效荷载
  - 结束字节标志

#### 3. 消息路由模式

- fanout模式

  fanout类型的Exchange路由规则会把所有**发送到该Exchange的消息路由到所有与它绑定的queue中**

- direct模式

  direct会把消息路由到**binding key与routing key完全匹配的queue中**

- topic模式

  topic类型的Exchange在**匹配规则上进行了扩展**，**与direct类型的exchange相似，以.进行分隔，用*号表示通配**

- headers模式

  不依赖于routing key与binding key的匹配规则来路由，而是**根据消息内容中的headers属性进行匹配**

## 10. 排序算法

https://www.cxyxiaowu.com/2026.html

- 冒泡排序
- 选择排序
- 插入排序

- 堆排序
  - 堆的结构
  
    **堆结构是一种近似完全完全二叉树的结构，每个节点都大于或等于其左右孩子节点的值称为大顶堆，每个节点的值都小于或等于其左右孩子节点的值称为小顶堆**
  
  - 堆排序思想
  
    将待排序序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点。将其与末尾的元素交换，末尾就是最大值。然后将剩余的n-1个元素重新构造成一个堆，这样会得到n个元素的次大值
  
  - 堆
    - 升序：大顶堆
    - 降序：小顶堆
    
  - 代码
  
    ```java
    // 递归向下调整
    // 建立大根堆
    // 每次输出都递归向下调整
    public void heapSort(int[] arr){
        int len = arr.length;
        buildMaxHeap(arr, len);
        // 每次确定一个最大值放在数组的最后面
        for(int i = len -1;i>=0; i--){
            swap(arr, 0, i);
            len --;
            heap(arr,0,len);
        }
    }
    private void bulidMaxHeap(int[] arr,int len){
        for(int i=len/2;i>=0;i--){
            heap(arr,i,len);
        }
    }
    private void heap(int[] arr,int i,int len){
        int root = i;
        int left = 2*i + 1;
        int right = 2*i + 2;
        if(left < len && arr[left] > arr[root]) root = left;
        if(right < len && arr[right] > arr[root]) root = right;
        if(root != i){
            swap(arr, i ,root);
            heap(arr,root,len);
        }
    }
    ```
  
- 快速排序

  - 代码

    ```java
    public void quickSort(int[] a, int s, int e){
        if(s >= e) return;
        int i = s,j = e;
        int pivot = a[s];
        while(i != j){
            while(i<j && a[j] >= pivot) j--;
            swap(a,i,j);
            while(i<j && a[i] <= pivot) i++;
            swap(a,i,j);
        }
        quickSort(a,s,i-1);
        quickSort(a,i+1,e);
    }
    ```

  - 思路

  - topK

- 归并排序

  - 代码

  ```
  // 1. 合并两个有序数组到一个数组里面
  // 2. 从将一个数组中间拆分为两个，递归，然后合并
  ```

  - 思路
  - 逆序数

- 计数排序

  开辟max-min+1大小的数组，在数组对应位置计算该下标数字出现的次数，然后还原

- 基数排序

  按位比较

- 桶排序

  分桶

## 11. 集群

### 1. 负载均衡

- 基本

  集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。

- 负载均衡器可以用来实现高可用以及伸缩性

  - 可用性：某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，保证所有服务持续可用
  - 伸缩性：根据系统整体负载情况，可以很容易添加或移除节点

- 负载均衡器

  - 根据负载均衡算法得到转发的节点
  - 进行转发

#### 2. 负载均衡算法

- 轮询（Round Robin）

  把每个请求轮流发送到每个服务器上

  一共有6个客户端产生了6个请求，这6个请求按（1,2,3,4,5,6）的顺序发送

- 加权轮询

  在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值

- 最少连接

  由于每个请求的连接时间不一样，使用轮询或加权轮询算法可能让一台服务器当前连接数过大，另一台服务器的连接过小，造成负载不均衡

  最少连接算法将请求发送给当前最少连接数的服务器

- 加权最少连接

  在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。

- 随机算法

  把请求随机发送到服务器上，与轮询类似

- 源地址哈希

  源地址对客户端IP计算哈希值以后，再对服务器数量取模得到目标服务器的序号

#### 3. 转发实现

- ~~HTTP重定向~~

  HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。

- DNS域名解析

  在DNS解析域名的同时使用负载均衡算法计算服务器IP地址，**能根据地理位置进行域名解析，返回离用户最近的服务器的IP地址**

  大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡

- 反向代理服务器

  用于代理服务端，隐藏真实的服务器，为服务器收发请求。

  用户的请求经过反向代理服务器才能到达源服务器，反向代理服务器可能成为性能瓶颈

- 网络层

  获取网络数据包，根据负载均衡算法计算源服务器的IP地址，并修改请求数据包的目的IP地址进行转发

- 链路层

  在链路层根据负载均衡算法计算源服务器的MAC地址，并修改请求数据包的目的MAC地址，并进行转发。

### 2. 集群下的Session管理 

- Sticky Session
- Sesion Replication
- Session Server